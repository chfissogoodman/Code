//==================================================================================//
// Author: GWX Technology
// Attribution: Verilog-HDL
// Birthday: Tue Oct 10 15:44:31 CST 2023
// Organization: GWX Technology
// Copyright: GWX Technology Â©2023 GWX Technology Inc. All rights reserved.
//----------------------------------------------------------------------------------//
// Description:
// All the data in the file was generated by GWX Technology. This information was
// prepared only for EDA tools training. GWX Technology does not guarantee the
// accuracy or completeness of the information contained herein. GWX Technology
// shall not be liable for any loss or damage of any kind arising from the use of
// this document or the information contained herein.
//----------------------------------------------------------------------------------//
// Version: 0.9.0.0 Alpha
//==================================================================================//

//   --------------------------------------------------------------     
//                       Template Revision : 3.6.3                      
//   --------------------------------------------------------------     
//                      * Synchronous, 2-Port SRAM *                  
//                      * Verilog Behavioral Model *                  
//                THIS IS A SYNCHRONOUS 2-PORT MEMORY MODEL           
//                                                                    
//   Memory Name:ram128x32_2p2r2w                                     
//   Memory Size:128 words x 32 bits                                  
//                                                                    
//                               PORT NAME                            
//                               ---------                            
//               Output Ports                                         
//                                   QA[31:0]                         
//                                   QB[31:0]                         
//               Input Ports:                                         
//                                   ADRA[6:0]                        
//                                   DA[31:0]                         
//                                   WEA                              
//                                   MEA                              
//                                   CLKA                             
//                                   TEST1A                           
//                                   RMEA                             
//                                   RMA[3:0]                         
//                                   ADRB[6:0]                        
//                                   DB[31:0]                         
//                                   WEB                              
//                                   MEB                              
//                                   CLKB                             
//                                   TEST1B                           
//                                   RMEB                             
//                                   RMB[3:0]                         
// -------------------------------------------------------------------- 

`resetall 
`timescale 1 ns / 1 ps 
`celldefine 
`ifdef verifault // for fault simulation purpose 
`suppress_faults 
`enable_portfaults 
`endif 

`define True    1'b1
`define False   1'b0

module ram128x32_2p2r2w ( QA, QB, ADRA, DA, WEA, MEA, CLKA, TEST1A, RMEA, RMA, ADRB, DB, WEB, MEB, CLKB, TEST1B, RMEB, RMB);

// Input/Output Ports Declaration
input WEA; // Memory Write Enable Input 
input MEA; // Memory Enable Input 
input CLKA; // Clock Input 
input TEST1A; // Test1 Input 
input RMEA; // Read Margin Enable Input 
input WEB; // Memory Write Enable Input 
input MEB; // Memory Enable Input 
input CLKB; // Clock Input 
input TEST1B; // Test1 Input 
input RMEB; // Read Margin Enable Input 
input  [6:0] ADRA; // Address Input 
input  [31:0] DA; // Data Input 
input  [3:0] RMA; // Read Margin Input 
input  [6:0] ADRB; // Address Input 
input  [31:0] DB; // Data Input 
input  [3:0] RMB; // Read Margin Input 
output  [31:0] QA; // Data Output Bus
output  [31:0] QB; // Data Output Bus


// Local registers, wires, etc
parameter PreloadFilename = "init.file";
`ifdef MEM_CHECK_OFF
parameter MES_ALL = "OFF";
`else
parameter MES_ALL = "ON";
`endif

`ifdef VIRAGE_FAST_VERILOG
reg sim_check_A ;
reg sim_check_B ;
`else
// Notifiers Declaration
reg notif_adra;
reg notif_da;
reg notif_wea;
reg notif_mea;
reg notif_clka;
reg notif_clka_CLKB_rise_rise_rec;
reg notif_test1a;
reg notif_rmea;
reg notif_rma;
reg notif_adrb;
reg notif_db;
reg notif_web;
reg notif_meb;
reg notif_clkb;
reg notif_clkb_CLKA_rise_rise_rec;
reg notif_test1b;
reg notif_rmeb;
reg notif_rmb;
`endif
`ifdef VIRAGE_FAST_VERILOG
`else
reg  EVENT_TCQ_A;
`endif
real  CLK_T_A;
reg  [6 : 0 ] ADRA_buf_L;
reg ADRFLAGA;
reg TADRFLAGA;
reg  [6 : 0 ] ADRA_old;
reg  MEA_old;
reg  WEA_old;
`ifdef VIRAGE_FAST_VERILOG
`else
reg  EVENT_TCQ_B;
`endif
real  CLK_T_B;
reg  [6 : 0 ] ADRB_buf_L;
reg ADRFLAGB;
reg TADRFLAGB;
reg  [6 : 0 ] ADRB_old;
reg  MEB_old;
reg  WEB_old;
wire [31:0] QA_final;
wire [31:0] QB_final;
`ifdef VIRAGE_FAST_VERILOG
wire [31:0] QA_buf;
assign QA[0] = QA_buf[0];
assign QA[1] = QA_buf[1];
assign QA[2] = QA_buf[2];
assign QA[3] = QA_buf[3];
assign QA[4] = QA_buf[4];
assign QA[5] = QA_buf[5];
assign QA[6] = QA_buf[6];
assign QA[7] = QA_buf[7];
assign QA[8] = QA_buf[8];
assign QA[9] = QA_buf[9];
assign QA[10] = QA_buf[10];
assign QA[11] = QA_buf[11];
assign QA[12] = QA_buf[12];
assign QA[13] = QA_buf[13];
assign QA[14] = QA_buf[14];
assign QA[15] = QA_buf[15];
assign QA[16] = QA_buf[16];
assign QA[17] = QA_buf[17];
assign QA[18] = QA_buf[18];
assign QA[19] = QA_buf[19];
assign QA[20] = QA_buf[20];
assign QA[21] = QA_buf[21];
assign QA[22] = QA_buf[22];
assign QA[23] = QA_buf[23];
assign QA[24] = QA_buf[24];
assign QA[25] = QA_buf[25];
assign QA[26] = QA_buf[26];
assign QA[27] = QA_buf[27];
assign QA[28] = QA_buf[28];
assign QA[29] = QA_buf[29];
assign QA[30] = QA_buf[30];
assign QA[31] = QA_buf[31];
wire [31:0] QB_buf;
assign QB[0] = QB_buf[0];
assign QB[1] = QB_buf[1];
assign QB[2] = QB_buf[2];
assign QB[3] = QB_buf[3];
assign QB[4] = QB_buf[4];
assign QB[5] = QB_buf[5];
assign QB[6] = QB_buf[6];
assign QB[7] = QB_buf[7];
assign QB[8] = QB_buf[8];
assign QB[9] = QB_buf[9];
assign QB[10] = QB_buf[10];
assign QB[11] = QB_buf[11];
assign QB[12] = QB_buf[12];
assign QB[13] = QB_buf[13];
assign QB[14] = QB_buf[14];
assign QB[15] = QB_buf[15];
assign QB[16] = QB_buf[16];
assign QB[17] = QB_buf[17];
assign QB[18] = QB_buf[18];
assign QB[19] = QB_buf[19];
assign QB[20] = QB_buf[20];
assign QB[21] = QB_buf[21];
assign QB[22] = QB_buf[22];
assign QB[23] = QB_buf[23];
assign QB[24] = QB_buf[24];
assign QB[25] = QB_buf[25];
assign QB[26] = QB_buf[26];
assign QB[27] = QB_buf[27];
assign QB[28] = QB_buf[28];
assign QB[29] = QB_buf[29];
assign QB[30] = QB_buf[30];
assign QB[31] = QB_buf[31];
wire [6:0] ADRA_buf;
assign  ADRA_buf[0] =  ADRA[0];
assign  ADRA_buf[1] =  ADRA[1];
assign  ADRA_buf[2] =  ADRA[2];
assign  ADRA_buf[3] =  ADRA[3];
assign  ADRA_buf[4] =  ADRA[4];
assign  ADRA_buf[5] =  ADRA[5];
assign  ADRA_buf[6] =  ADRA[6];
wire [31:0] DA_buf;
assign  DA_buf[0] =  DA[0];
assign  DA_buf[1] =  DA[1];
assign  DA_buf[2] =  DA[2];
assign  DA_buf[3] =  DA[3];
assign  DA_buf[4] =  DA[4];
assign  DA_buf[5] =  DA[5];
assign  DA_buf[6] =  DA[6];
assign  DA_buf[7] =  DA[7];
assign  DA_buf[8] =  DA[8];
assign  DA_buf[9] =  DA[9];
assign  DA_buf[10] =  DA[10];
assign  DA_buf[11] =  DA[11];
assign  DA_buf[12] =  DA[12];
assign  DA_buf[13] =  DA[13];
assign  DA_buf[14] =  DA[14];
assign  DA_buf[15] =  DA[15];
assign  DA_buf[16] =  DA[16];
assign  DA_buf[17] =  DA[17];
assign  DA_buf[18] =  DA[18];
assign  DA_buf[19] =  DA[19];
assign  DA_buf[20] =  DA[20];
assign  DA_buf[21] =  DA[21];
assign  DA_buf[22] =  DA[22];
assign  DA_buf[23] =  DA[23];
assign  DA_buf[24] =  DA[24];
assign  DA_buf[25] =  DA[25];
assign  DA_buf[26] =  DA[26];
assign  DA_buf[27] =  DA[27];
assign  DA_buf[28] =  DA[28];
assign  DA_buf[29] =  DA[29];
assign  DA_buf[30] =  DA[30];
assign  DA_buf[31] =  DA[31];
wire WEA_buf;
assign  WEA_buf =  WEA;
wire MEA_buf;
assign  MEA_buf =  MEA;
wire CLKA_buf;
assign  CLKA_buf =  CLKA;
wire TEST1A_buf;
assign  TEST1A_buf =  TEST1A;
wire RMEA_buf;
assign  RMEA_buf =  RMEA;
wire [3:0] RMA_int;
wire [3:0] RMA_buf;
assign  RMA_buf[0] =  RMA[0];
assign  RMA_buf[1] =  RMA[1];
assign  RMA_buf[2] =  RMA[2];
assign  RMA_buf[3] =  RMA[3];
wire [6:0] ADRB_buf;
assign  ADRB_buf[0] =  ADRB[0];
assign  ADRB_buf[1] =  ADRB[1];
assign  ADRB_buf[2] =  ADRB[2];
assign  ADRB_buf[3] =  ADRB[3];
assign  ADRB_buf[4] =  ADRB[4];
assign  ADRB_buf[5] =  ADRB[5];
assign  ADRB_buf[6] =  ADRB[6];
wire [31:0] DB_buf;
assign  DB_buf[0] =  DB[0];
assign  DB_buf[1] =  DB[1];
assign  DB_buf[2] =  DB[2];
assign  DB_buf[3] =  DB[3];
assign  DB_buf[4] =  DB[4];
assign  DB_buf[5] =  DB[5];
assign  DB_buf[6] =  DB[6];
assign  DB_buf[7] =  DB[7];
assign  DB_buf[8] =  DB[8];
assign  DB_buf[9] =  DB[9];
assign  DB_buf[10] =  DB[10];
assign  DB_buf[11] =  DB[11];
assign  DB_buf[12] =  DB[12];
assign  DB_buf[13] =  DB[13];
assign  DB_buf[14] =  DB[14];
assign  DB_buf[15] =  DB[15];
assign  DB_buf[16] =  DB[16];
assign  DB_buf[17] =  DB[17];
assign  DB_buf[18] =  DB[18];
assign  DB_buf[19] =  DB[19];
assign  DB_buf[20] =  DB[20];
assign  DB_buf[21] =  DB[21];
assign  DB_buf[22] =  DB[22];
assign  DB_buf[23] =  DB[23];
assign  DB_buf[24] =  DB[24];
assign  DB_buf[25] =  DB[25];
assign  DB_buf[26] =  DB[26];
assign  DB_buf[27] =  DB[27];
assign  DB_buf[28] =  DB[28];
assign  DB_buf[29] =  DB[29];
assign  DB_buf[30] =  DB[30];
assign  DB_buf[31] =  DB[31];
wire WEB_buf;
assign  WEB_buf =  WEB;
wire MEB_buf;
assign  MEB_buf =  MEB;
wire CLKB_buf;
assign  CLKB_buf =  CLKB;
wire TEST1B_buf;
assign  TEST1B_buf =  TEST1B;
wire RMEB_buf;
assign  RMEB_buf =  RMEB;
wire [3:0] RMB_int;
wire [3:0] RMB_buf;
assign  RMB_buf[0] =  RMB[0];
assign  RMB_buf[1] =  RMB[1];
assign  RMB_buf[2] =  RMB[2];
assign  RMB_buf[3] =  RMB[3];
`else
wire [31:0] QA_buf;
buf (QA[0], QA_buf[0]);
buf (QA_final[0],QA[0]);
buf (QA[1], QA_buf[1]);
buf (QA_final[1],QA[1]);
buf (QA[2], QA_buf[2]);
buf (QA_final[2],QA[2]);
buf (QA[3], QA_buf[3]);
buf (QA_final[3],QA[3]);
buf (QA[4], QA_buf[4]);
buf (QA_final[4],QA[4]);
buf (QA[5], QA_buf[5]);
buf (QA_final[5],QA[5]);
buf (QA[6], QA_buf[6]);
buf (QA_final[6],QA[6]);
buf (QA[7], QA_buf[7]);
buf (QA_final[7],QA[7]);
buf (QA[8], QA_buf[8]);
buf (QA_final[8],QA[8]);
buf (QA[9], QA_buf[9]);
buf (QA_final[9],QA[9]);
buf (QA[10], QA_buf[10]);
buf (QA_final[10],QA[10]);
buf (QA[11], QA_buf[11]);
buf (QA_final[11],QA[11]);
buf (QA[12], QA_buf[12]);
buf (QA_final[12],QA[12]);
buf (QA[13], QA_buf[13]);
buf (QA_final[13],QA[13]);
buf (QA[14], QA_buf[14]);
buf (QA_final[14],QA[14]);
buf (QA[15], QA_buf[15]);
buf (QA_final[15],QA[15]);
buf (QA[16], QA_buf[16]);
buf (QA_final[16],QA[16]);
buf (QA[17], QA_buf[17]);
buf (QA_final[17],QA[17]);
buf (QA[18], QA_buf[18]);
buf (QA_final[18],QA[18]);
buf (QA[19], QA_buf[19]);
buf (QA_final[19],QA[19]);
buf (QA[20], QA_buf[20]);
buf (QA_final[20],QA[20]);
buf (QA[21], QA_buf[21]);
buf (QA_final[21],QA[21]);
buf (QA[22], QA_buf[22]);
buf (QA_final[22],QA[22]);
buf (QA[23], QA_buf[23]);
buf (QA_final[23],QA[23]);
buf (QA[24], QA_buf[24]);
buf (QA_final[24],QA[24]);
buf (QA[25], QA_buf[25]);
buf (QA_final[25],QA[25]);
buf (QA[26], QA_buf[26]);
buf (QA_final[26],QA[26]);
buf (QA[27], QA_buf[27]);
buf (QA_final[27],QA[27]);
buf (QA[28], QA_buf[28]);
buf (QA_final[28],QA[28]);
buf (QA[29], QA_buf[29]);
buf (QA_final[29],QA[29]);
buf (QA[30], QA_buf[30]);
buf (QA_final[30],QA[30]);
buf (QA[31], QA_buf[31]);
buf (QA_final[31],QA[31]);
wire [31:0] QB_buf;
buf (QB[0], QB_buf[0]);
buf (QB_final[0],QB[0]);
buf (QB[1], QB_buf[1]);
buf (QB_final[1],QB[1]);
buf (QB[2], QB_buf[2]);
buf (QB_final[2],QB[2]);
buf (QB[3], QB_buf[3]);
buf (QB_final[3],QB[3]);
buf (QB[4], QB_buf[4]);
buf (QB_final[4],QB[4]);
buf (QB[5], QB_buf[5]);
buf (QB_final[5],QB[5]);
buf (QB[6], QB_buf[6]);
buf (QB_final[6],QB[6]);
buf (QB[7], QB_buf[7]);
buf (QB_final[7],QB[7]);
buf (QB[8], QB_buf[8]);
buf (QB_final[8],QB[8]);
buf (QB[9], QB_buf[9]);
buf (QB_final[9],QB[9]);
buf (QB[10], QB_buf[10]);
buf (QB_final[10],QB[10]);
buf (QB[11], QB_buf[11]);
buf (QB_final[11],QB[11]);
buf (QB[12], QB_buf[12]);
buf (QB_final[12],QB[12]);
buf (QB[13], QB_buf[13]);
buf (QB_final[13],QB[13]);
buf (QB[14], QB_buf[14]);
buf (QB_final[14],QB[14]);
buf (QB[15], QB_buf[15]);
buf (QB_final[15],QB[15]);
buf (QB[16], QB_buf[16]);
buf (QB_final[16],QB[16]);
buf (QB[17], QB_buf[17]);
buf (QB_final[17],QB[17]);
buf (QB[18], QB_buf[18]);
buf (QB_final[18],QB[18]);
buf (QB[19], QB_buf[19]);
buf (QB_final[19],QB[19]);
buf (QB[20], QB_buf[20]);
buf (QB_final[20],QB[20]);
buf (QB[21], QB_buf[21]);
buf (QB_final[21],QB[21]);
buf (QB[22], QB_buf[22]);
buf (QB_final[22],QB[22]);
buf (QB[23], QB_buf[23]);
buf (QB_final[23],QB[23]);
buf (QB[24], QB_buf[24]);
buf (QB_final[24],QB[24]);
buf (QB[25], QB_buf[25]);
buf (QB_final[25],QB[25]);
buf (QB[26], QB_buf[26]);
buf (QB_final[26],QB[26]);
buf (QB[27], QB_buf[27]);
buf (QB_final[27],QB[27]);
buf (QB[28], QB_buf[28]);
buf (QB_final[28],QB[28]);
buf (QB[29], QB_buf[29]);
buf (QB_final[29],QB[29]);
buf (QB[30], QB_buf[30]);
buf (QB_final[30],QB[30]);
buf (QB[31], QB_buf[31]);
buf (QB_final[31],QB[31]);
wire [6:0] ADRA_buf;
buf (ADRA_buf[0], ADRA[0]);
buf (ADRA_buf[1], ADRA[1]);
buf (ADRA_buf[2], ADRA[2]);
buf (ADRA_buf[3], ADRA[3]);
buf (ADRA_buf[4], ADRA[4]);
buf (ADRA_buf[5], ADRA[5]);
buf (ADRA_buf[6], ADRA[6]);
wire [31:0] DA_buf;
buf (DA_buf[0], DA[0]);
buf (DA_buf[1], DA[1]);
buf (DA_buf[2], DA[2]);
buf (DA_buf[3], DA[3]);
buf (DA_buf[4], DA[4]);
buf (DA_buf[5], DA[5]);
buf (DA_buf[6], DA[6]);
buf (DA_buf[7], DA[7]);
buf (DA_buf[8], DA[8]);
buf (DA_buf[9], DA[9]);
buf (DA_buf[10], DA[10]);
buf (DA_buf[11], DA[11]);
buf (DA_buf[12], DA[12]);
buf (DA_buf[13], DA[13]);
buf (DA_buf[14], DA[14]);
buf (DA_buf[15], DA[15]);
buf (DA_buf[16], DA[16]);
buf (DA_buf[17], DA[17]);
buf (DA_buf[18], DA[18]);
buf (DA_buf[19], DA[19]);
buf (DA_buf[20], DA[20]);
buf (DA_buf[21], DA[21]);
buf (DA_buf[22], DA[22]);
buf (DA_buf[23], DA[23]);
buf (DA_buf[24], DA[24]);
buf (DA_buf[25], DA[25]);
buf (DA_buf[26], DA[26]);
buf (DA_buf[27], DA[27]);
buf (DA_buf[28], DA[28]);
buf (DA_buf[29], DA[29]);
buf (DA_buf[30], DA[30]);
buf (DA_buf[31], DA[31]);
buf (WEA_buf, WEA);
buf (MEA_buf, MEA);
buf (CLKA_buf, CLKA);
buf (TEST1A_buf, TEST1A);
buf (RMEA_buf, RMEA);
wire [3:0] RMA_int;
wire [3:0] RMA_buf;
buf (RMA_buf[0], RMA[0]);
buf (RMA_buf[1], RMA[1]);
buf (RMA_buf[2], RMA[2]);
buf (RMA_buf[3], RMA[3]);
wire [6:0] ADRB_buf;
buf (ADRB_buf[0], ADRB[0]);
buf (ADRB_buf[1], ADRB[1]);
buf (ADRB_buf[2], ADRB[2]);
buf (ADRB_buf[3], ADRB[3]);
buf (ADRB_buf[4], ADRB[4]);
buf (ADRB_buf[5], ADRB[5]);
buf (ADRB_buf[6], ADRB[6]);
wire [31:0] DB_buf;
buf (DB_buf[0], DB[0]);
buf (DB_buf[1], DB[1]);
buf (DB_buf[2], DB[2]);
buf (DB_buf[3], DB[3]);
buf (DB_buf[4], DB[4]);
buf (DB_buf[5], DB[5]);
buf (DB_buf[6], DB[6]);
buf (DB_buf[7], DB[7]);
buf (DB_buf[8], DB[8]);
buf (DB_buf[9], DB[9]);
buf (DB_buf[10], DB[10]);
buf (DB_buf[11], DB[11]);
buf (DB_buf[12], DB[12]);
buf (DB_buf[13], DB[13]);
buf (DB_buf[14], DB[14]);
buf (DB_buf[15], DB[15]);
buf (DB_buf[16], DB[16]);
buf (DB_buf[17], DB[17]);
buf (DB_buf[18], DB[18]);
buf (DB_buf[19], DB[19]);
buf (DB_buf[20], DB[20]);
buf (DB_buf[21], DB[21]);
buf (DB_buf[22], DB[22]);
buf (DB_buf[23], DB[23]);
buf (DB_buf[24], DB[24]);
buf (DB_buf[25], DB[25]);
buf (DB_buf[26], DB[26]);
buf (DB_buf[27], DB[27]);
buf (DB_buf[28], DB[28]);
buf (DB_buf[29], DB[29]);
buf (DB_buf[30], DB[30]);
buf (DB_buf[31], DB[31]);
buf (WEB_buf, WEB);
buf (MEB_buf, MEB);
buf (CLKB_buf, CLKB);
buf (TEST1B_buf, TEST1B);
buf (RMEB_buf, RMEB);
wire [3:0] RMB_int;
wire [3:0] RMB_buf;
buf (RMB_buf[0], RMB[0]);
buf (RMB_buf[1], RMB[1]);
buf (RMB_buf[2], RMB[2]);
buf (RMB_buf[3], RMB[3]);
 
always @ (QA_final)
begin : blk_dofinal_0  
  if (QA_final !== 32'bx )
  begin
    EVENT_TCQ_A = 1'b0;
  end // if of QA_final != X
end // end of always block blk_dofinal_0
 
always @ (QB_final)
begin : blk_dofinal_1  
  if (QB_final !== 32'bx )
  begin
    EVENT_TCQ_B = 1'b0;
  end // if of QB_final != X
end // end of always block blk_dofinal_1
`endif
wire ADRA_valid;
//assign ADRA_valid =  (ADRA_buf >= 7'b0000000 && ADRA_buf <= 7'b1111111 )?1'b1:1'b0;
assign ADRA_valid =  (ADRA_buf <= 7'b1111111 )?1'b1:1'b0;
wire ADRB_valid;
//assign ADRB_valid =  (ADRB_buf >= 7'b0000000 && ADRB_buf <= 7'b1111111 )?1'b1:1'b0;
assign ADRB_valid =  (ADRB_buf <= 7'b1111111 )?1'b1:1'b0;
// Setup/hold conditions for syncronous signals
`ifdef VIRAGE_FAST_VERILOG
`else
reg  MEA_pre,WEA_pre;

always @(MEA_buf or negedge CLKA_buf) 
begin : blk_mebuf_0
  if ( CLKA_buf == 1'b0)
  begin
    MEA_pre = MEA_buf;
  end // if of CLKA_buf = 0
end // end of always block blk_mebuf_0

always @(WEA_buf or negedge CLKA_buf) 
begin : blk_webuf_0
  if ( CLKA_buf == 1'b0)
  begin
    WEA_pre = WEA_buf;
  end // if of CLKA_buf = 0
end // end of always block blk_webuf_0

// Setup/hold condition for Address: ADRA is : ENADRA
wire ENADRA;
buf ( ENADRA, MEA_pre );
 
// Setup/hold condition for Memory Enable: MEA is : ENMEA
wire ENMEA;
buf ( ENMEA, ADRA_valid );

// Setup/hold condition for Write Enable: WEA is : ENWEA
wire ENWEA;
assign ENWEA = (( ADRA_valid && MEA_pre !== 1'b0 ) ?1'b1:1'b0);

// Setup/hold condition for Data In: DA is : ENDA
wire ENDA;
assign ENDA = (( ADRA_valid && MEA_pre !== 1'b0 && WEA_pre !== 1'b0 )?1'b1:1'b0) ;
// Setup/hold condition for test1 Vector: TEST1A is : ENTEST1A
wire ENTEST1A;
assign ENTEST1A = ((MEA_pre !== 1'b0 && ADRA_valid)?1'b1:1'b0);
 
// Setup/hold condition for Read Margin Vector: RMA is : ENRMA
wire ENRMA;
assign ENRMA = ((RMEA_buf === 1'b1 && (MEA_pre !== 1'b0 && ADRA_valid))?1'b1:1'b0);
// Setup/hold condition for Read Margin Vector Enable: RMEA is : ENRMEA
wire ENRMEA;
assign ENRMEA = ((MEA_pre !== 1'b0 && ADRA_valid)?1'b1:1'b0);
wire ENCLKA_rmezo,ENCLKA_vdm,ENCLKA_slw,ENCLKA_def,ENCLKA_fst;
assign ENCLKA_rmezo = ((RMEA_buf !== 1'b1)?1'b1:1'b0) ;
assign ENCLKA_vdm = ((RMEA_buf === 1'b1  && ( (!RMA_buf[0]) && (!RMA_buf[1]) && (!RMA_buf[2]) && (!RMA_buf[3]) ))?1'b1:1'b0) ;
assign ENCLKA_slw = ((RMEA_buf === 1'b1  && ( (RMA_buf[0]) && (!RMA_buf[1]) && (!RMA_buf[2]) && (!RMA_buf[3]) ))?1'b1:1'b0) ;
assign ENCLKA_def = ((RMEA_buf === 1'b1  && ( (!RMA_buf[0]) && (RMA_buf[1]) && (!RMA_buf[2]) && (!RMA_buf[3]) ))?1'b1:1'b0) ;
assign ENCLKA_fst = ((RMEA_buf === 1'b1  && ( (RMA_buf[0]) && (RMA_buf[1]) && (!RMA_buf[2]) && (!RMA_buf[3]) ))?1'b1:1'b0) ;
`endif // endif of VIRAGE_FAST_VERILOG
`ifdef VIRAGE_FAST_VERILOG
`else
reg  MEB_pre,WEB_pre;

always @(MEB_buf or negedge CLKB_buf) 
begin : blk_mebuf_1
  if ( CLKB_buf == 1'b0)
  begin
    MEB_pre = MEB_buf;
  end // if of CLKB_buf = 0
end // end of always block blk_mebuf_1

always @(WEB_buf or negedge CLKB_buf) 
begin : blk_webuf_1
  if ( CLKB_buf == 1'b0)
  begin
    WEB_pre = WEB_buf;
  end // if of CLKB_buf = 0
end // end of always block blk_webuf_1

// Setup/hold condition for Address: ADRB is : ENADRB
wire ENADRB;
buf ( ENADRB, MEB_pre );
 
// Setup/hold condition for Memory Enable: MEB is : ENMEB
wire ENMEB;
buf ( ENMEB, ADRB_valid );

// Setup/hold condition for Write Enable: WEB is : ENWEB
wire ENWEB;
assign ENWEB = (( ADRB_valid && MEB_pre !== 1'b0 ) ?1'b1:1'b0);

// Setup/hold condition for Data In: DB is : ENDB
wire ENDB;
assign ENDB = (( ADRB_valid && MEB_pre !== 1'b0 && WEB_pre !== 1'b0 )?1'b1:1'b0) ;
// Setup/hold condition for test1 Vector: TEST1B is : ENTEST1B
wire ENTEST1B;
assign ENTEST1B = ((MEB_pre !== 1'b0 && ADRB_valid)?1'b1:1'b0);
 
// Setup/hold condition for Read Margin Vector: RMB is : ENRMB
wire ENRMB;
assign ENRMB = ((RMEB_buf === 1'b1 && (MEB_pre !== 1'b0 && ADRB_valid))?1'b1:1'b0);
// Setup/hold condition for Read Margin Vector Enable: RMEB is : ENRMEB
wire ENRMEB;
assign ENRMEB = ((MEB_pre !== 1'b0 && ADRB_valid)?1'b1:1'b0);
wire ENCLKB_rmezo,ENCLKB_vdm,ENCLKB_slw,ENCLKB_def,ENCLKB_fst;
assign ENCLKB_rmezo = ((RMEB_buf !== 1'b1)?1'b1:1'b0) ;
assign ENCLKB_vdm = ((RMEB_buf === 1'b1  && ( (!RMB_buf[0]) && (!RMB_buf[1]) && (!RMB_buf[2]) && (!RMB_buf[3]) ))?1'b1:1'b0) ;
assign ENCLKB_slw = ((RMEB_buf === 1'b1  && ( (RMB_buf[0]) && (!RMB_buf[1]) && (!RMB_buf[2]) && (!RMB_buf[3]) ))?1'b1:1'b0) ;
assign ENCLKB_def = ((RMEB_buf === 1'b1  && ( (!RMB_buf[0]) && (RMB_buf[1]) && (!RMB_buf[2]) && (!RMB_buf[3]) ))?1'b1:1'b0) ;
assign ENCLKB_fst = ((RMEB_buf === 1'b1  && ( (RMB_buf[0]) && (RMB_buf[1]) && (!RMB_buf[2]) && (!RMB_buf[3]) ))?1'b1:1'b0) ;
`endif // endif of VIRAGE_FAST_VERILOG
reg MEA_buf_L;
reg WEA_buf_L;
`ifdef VIRAGE_FAST_VERILOG
`else
`endif // endif of VIRAGE_FAST_VERILOG
reg MEB_buf_L;
reg WEB_buf_L;
`ifdef VIRAGE_FAST_VERILOG
`else
`endif // endif of VIRAGE_FAST_VERILOG
wire adr_same_a;
wire adr_valid_a;
`ifdef VIRAGE_FAST_VERILOG
`else
wire we_activeA;
wire me_activeA;
wire ENCLKACLKBrec;
wire ENCLKBCLKArec;
assign adr_same_a = (((ADRA_old == ADRB_buf_L) && ADRFLAGA) || (CLKA_buf === 1'bx || CLKB_buf === 1'bx) || ((ADRA_old^ADRA_old) !== 0) || ((ADRB_buf_L^ADRB_buf_L) !== 0)) ? 1'b1:1'b0;
`endif // endif of VIRAGE_FAST_VERILOG
`ifdef VIRAGE_FAST_VERILOG
`else
assign we_activeA = ( ( WEA_old === 1'b0 ) && ( WEB_buf_L === 1'b0 ))?1'b0:1'b1;
assign me_activeA = ( ( MEA_old !== 1'b0 ) && ( MEB_buf_L !== 1'b0 ))?1'b1:1'b0;
and u_rec_0 ( ENCLKBCLKArec, rise_time_same, adr_same_a, me_activeA, we_activeA);
`endif // endif of VIRAGE_FAST_VERILOG
wire adr_same_b;
wire adr_valid_b;
`ifdef VIRAGE_FAST_VERILOG
`else
wire we_activeB;
wire me_activeB;
assign adr_same_b = (((ADRB_old == ADRA_buf_L) && ADRFLAGB) || (CLKB_buf === 1'bx || CLKA_buf === 1'bx) || ((ADRB_old^ADRB_old) !== 0) || ((ADRA_buf_L^ADRA_buf_L) !== 0)) ? 1'b1:1'b0;
`endif // endif of VIRAGE_FAST_VERILOG
`ifdef VIRAGE_FAST_VERILOG
`else
assign we_activeB = ( ( WEB_old === 1'b0 ) && ( WEA_buf_L === 1'b0 ))?1'b0:1'b1;
assign me_activeB = ( ( MEB_old !== 1'b0 ) && ( MEA_buf_L !== 1'b0 ))?1'b1:1'b0;
and u_rec_1 ( ENCLKACLKBrec, rise_time_same, adr_same_b, me_activeB, we_activeB);
`endif // endif of VIRAGE_FAST_VERILOG

`ifdef VIRAGE_FAST_VERILOG
`else
specify
 
  specparam
    Tac = 0.424,
    Tcax = 0.064,
    Tdc = 0.276,
    Tcdx = 0.064,
    Twc = 0.421,
    Tcwx = 0.040,
    Tmc = 0.919,
    Tcmx = 0.000,
    Tcsep = 1.355,
    Tcl = 0.332,
    Tch = 0.202,
    Tcc = 1.355,
    Tccvddmin = 1.555,
    Tccslow = 1.431,
    Tccdef = 1.355,
    Tccfast = 1.096,
    TT1C = 0.000,
    TCT1X = 0.371,
    Trmec = 0.406,
    Tcrmex = 0.034,
    Trmc = 0.381,
    Tcrmx = 0.009,
    Tcq = 0.825,
    Tcqx = 0.801,
    Tcqvddmin = 1.262,
    Tcqvddminx = 1.223,
    Tcqslow = 0.830,
    Tcqslowx = 0.802,
    Tcqdef = 0.825,
    Tcqdefx = 0.801,
    Tcqfast = 0.809,
    Tcqfastx = 0.798;
     if (   !RMEA )
       ( posedge CLKA => (  QA[31]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RMEA )
       ( posedge CLKA => (  QA[30]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RMEA )
       ( posedge CLKA => (  QA[29]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RMEA )
       ( posedge CLKA => (  QA[28]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RMEA )
       ( posedge CLKA => (  QA[27]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RMEA )
       ( posedge CLKA => (  QA[26]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RMEA )
       ( posedge CLKA => (  QA[25]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RMEA )
       ( posedge CLKA => (  QA[24]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RMEA )
       ( posedge CLKA => (  QA[23]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RMEA )
       ( posedge CLKA => (  QA[22]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RMEA )
       ( posedge CLKA => (  QA[21]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RMEA )
       ( posedge CLKA => (  QA[20]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RMEA )
       ( posedge CLKA => (  QA[19]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RMEA )
       ( posedge CLKA => (  QA[18]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RMEA )
       ( posedge CLKA => (  QA[17]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RMEA )
       ( posedge CLKA => (  QA[16]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RMEA )
       ( posedge CLKA => (  QA[15]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RMEA )
       ( posedge CLKA => (  QA[14]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RMEA )
       ( posedge CLKA => (  QA[13]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RMEA )
       ( posedge CLKA => (  QA[12]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RMEA )
       ( posedge CLKA => (  QA[11]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RMEA )
       ( posedge CLKA => (  QA[10]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RMEA )
       ( posedge CLKA => (  QA[9]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RMEA )
       ( posedge CLKA => (  QA[8]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RMEA )
       ( posedge CLKA => (  QA[7]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RMEA )
       ( posedge CLKA => (  QA[6]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RMEA )
       ( posedge CLKA => (  QA[5]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RMEA )
       ( posedge CLKA => (  QA[4]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RMEA )
       ( posedge CLKA => (  QA[3]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RMEA )
       ( posedge CLKA => (  QA[2]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RMEA )
       ( posedge CLKA => (  QA[1]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RMEA )
       ( posedge CLKA => (  QA[0]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   RMEA &  !RMA[0] & !RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[31]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEA &  !RMA[0] & !RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[30]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEA &  !RMA[0] & !RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[29]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEA &  !RMA[0] & !RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[28]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEA &  !RMA[0] & !RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[27]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEA &  !RMA[0] & !RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[26]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEA &  !RMA[0] & !RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[25]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEA &  !RMA[0] & !RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[24]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEA &  !RMA[0] & !RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[23]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEA &  !RMA[0] & !RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[22]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEA &  !RMA[0] & !RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[21]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEA &  !RMA[0] & !RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[20]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEA &  !RMA[0] & !RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[19]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEA &  !RMA[0] & !RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[18]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEA &  !RMA[0] & !RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[17]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEA &  !RMA[0] & !RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[16]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEA &  !RMA[0] & !RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[15]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEA &  !RMA[0] & !RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[14]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEA &  !RMA[0] & !RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[13]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEA &  !RMA[0] & !RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[12]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEA &  !RMA[0] & !RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[11]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEA &  !RMA[0] & !RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[10]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEA &  !RMA[0] & !RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[9]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEA &  !RMA[0] & !RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[8]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEA &  !RMA[0] & !RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[7]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEA &  !RMA[0] & !RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[6]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEA &  !RMA[0] & !RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[5]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEA &  !RMA[0] & !RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[4]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEA &  !RMA[0] & !RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[3]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEA &  !RMA[0] & !RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[2]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEA &  !RMA[0] & !RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[1]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEA &  !RMA[0] & !RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[0]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEA &  RMA[0] & !RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[31]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEA &  RMA[0] & !RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[30]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEA &  RMA[0] & !RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[29]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEA &  RMA[0] & !RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[28]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEA &  RMA[0] & !RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[27]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEA &  RMA[0] & !RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[26]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEA &  RMA[0] & !RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[25]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEA &  RMA[0] & !RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[24]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEA &  RMA[0] & !RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[23]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEA &  RMA[0] & !RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[22]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEA &  RMA[0] & !RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[21]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEA &  RMA[0] & !RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[20]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEA &  RMA[0] & !RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[19]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEA &  RMA[0] & !RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[18]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEA &  RMA[0] & !RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[17]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEA &  RMA[0] & !RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[16]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEA &  RMA[0] & !RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[15]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEA &  RMA[0] & !RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[14]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEA &  RMA[0] & !RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[13]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEA &  RMA[0] & !RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[12]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEA &  RMA[0] & !RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[11]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEA &  RMA[0] & !RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[10]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEA &  RMA[0] & !RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[9]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEA &  RMA[0] & !RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[8]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEA &  RMA[0] & !RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[7]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEA &  RMA[0] & !RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[6]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEA &  RMA[0] & !RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[5]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEA &  RMA[0] & !RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[4]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEA &  RMA[0] & !RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[3]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEA &  RMA[0] & !RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[2]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEA &  RMA[0] & !RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[1]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEA &  RMA[0] & !RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[0]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEA &  !RMA[0] & RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[31]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEA &  !RMA[0] & RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[30]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEA &  !RMA[0] & RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[29]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEA &  !RMA[0] & RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[28]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEA &  !RMA[0] & RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[27]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEA &  !RMA[0] & RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[26]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEA &  !RMA[0] & RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[25]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEA &  !RMA[0] & RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[24]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEA &  !RMA[0] & RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[23]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEA &  !RMA[0] & RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[22]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEA &  !RMA[0] & RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[21]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEA &  !RMA[0] & RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[20]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEA &  !RMA[0] & RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[19]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEA &  !RMA[0] & RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[18]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEA &  !RMA[0] & RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[17]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEA &  !RMA[0] & RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[16]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEA &  !RMA[0] & RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[15]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEA &  !RMA[0] & RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[14]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEA &  !RMA[0] & RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[13]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEA &  !RMA[0] & RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[12]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEA &  !RMA[0] & RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[11]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEA &  !RMA[0] & RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[10]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEA &  !RMA[0] & RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[9]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEA &  !RMA[0] & RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[8]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEA &  !RMA[0] & RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[7]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEA &  !RMA[0] & RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[6]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEA &  !RMA[0] & RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[5]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEA &  !RMA[0] & RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[4]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEA &  !RMA[0] & RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[3]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEA &  !RMA[0] & RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[2]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEA &  !RMA[0] & RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[1]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEA &  !RMA[0] & RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[0]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEA &  RMA[0] & RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[31]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RMEA &  RMA[0] & RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[30]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RMEA &  RMA[0] & RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[29]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RMEA &  RMA[0] & RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[28]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RMEA &  RMA[0] & RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[27]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RMEA &  RMA[0] & RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[26]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RMEA &  RMA[0] & RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[25]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RMEA &  RMA[0] & RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[24]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RMEA &  RMA[0] & RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[23]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RMEA &  RMA[0] & RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[22]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RMEA &  RMA[0] & RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[21]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RMEA &  RMA[0] & RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[20]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RMEA &  RMA[0] & RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[19]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RMEA &  RMA[0] & RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[18]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RMEA &  RMA[0] & RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[17]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RMEA &  RMA[0] & RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[16]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RMEA &  RMA[0] & RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[15]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RMEA &  RMA[0] & RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[14]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RMEA &  RMA[0] & RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[13]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RMEA &  RMA[0] & RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[12]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RMEA &  RMA[0] & RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[11]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RMEA &  RMA[0] & RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[10]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RMEA &  RMA[0] & RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[9]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RMEA &  RMA[0] & RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[8]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RMEA &  RMA[0] & RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[7]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RMEA &  RMA[0] & RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[6]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RMEA &  RMA[0] & RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[5]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RMEA &  RMA[0] & RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[4]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RMEA &  RMA[0] & RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[3]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RMEA &  RMA[0] & RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[2]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RMEA &  RMA[0] & RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[1]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RMEA &  RMA[0] & RMA[1] & !RMA[2] & !RMA[3]  )
       ( posedge CLKA => (  QA[0]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   !RMEB )
       ( posedge CLKB => (  QB[31]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RMEB )
       ( posedge CLKB => (  QB[30]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RMEB )
       ( posedge CLKB => (  QB[29]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RMEB )
       ( posedge CLKB => (  QB[28]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RMEB )
       ( posedge CLKB => (  QB[27]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RMEB )
       ( posedge CLKB => (  QB[26]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RMEB )
       ( posedge CLKB => (  QB[25]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RMEB )
       ( posedge CLKB => (  QB[24]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RMEB )
       ( posedge CLKB => (  QB[23]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RMEB )
       ( posedge CLKB => (  QB[22]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RMEB )
       ( posedge CLKB => (  QB[21]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RMEB )
       ( posedge CLKB => (  QB[20]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RMEB )
       ( posedge CLKB => (  QB[19]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RMEB )
       ( posedge CLKB => (  QB[18]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RMEB )
       ( posedge CLKB => (  QB[17]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RMEB )
       ( posedge CLKB => (  QB[16]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RMEB )
       ( posedge CLKB => (  QB[15]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RMEB )
       ( posedge CLKB => (  QB[14]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RMEB )
       ( posedge CLKB => (  QB[13]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RMEB )
       ( posedge CLKB => (  QB[12]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RMEB )
       ( posedge CLKB => (  QB[11]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RMEB )
       ( posedge CLKB => (  QB[10]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RMEB )
       ( posedge CLKB => (  QB[9]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RMEB )
       ( posedge CLKB => (  QB[8]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RMEB )
       ( posedge CLKB => (  QB[7]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RMEB )
       ( posedge CLKB => (  QB[6]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RMEB )
       ( posedge CLKB => (  QB[5]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RMEB )
       ( posedge CLKB => (  QB[4]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RMEB )
       ( posedge CLKB => (  QB[3]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RMEB )
       ( posedge CLKB => (  QB[2]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RMEB )
       ( posedge CLKB => (  QB[1]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RMEB )
       ( posedge CLKB => (  QB[0]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   RMEB &  !RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[31]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEB &  !RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[30]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEB &  !RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[29]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEB &  !RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[28]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEB &  !RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[27]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEB &  !RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[26]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEB &  !RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[25]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEB &  !RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[24]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEB &  !RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[23]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEB &  !RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[22]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEB &  !RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[21]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEB &  !RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[20]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEB &  !RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[19]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEB &  !RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[18]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEB &  !RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[17]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEB &  !RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[16]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEB &  !RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[15]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEB &  !RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[14]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEB &  !RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[13]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEB &  !RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[12]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEB &  !RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[11]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEB &  !RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[10]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEB &  !RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[9]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEB &  !RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[8]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEB &  !RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[7]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEB &  !RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[6]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEB &  !RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[5]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEB &  !RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[4]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEB &  !RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[3]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEB &  !RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[2]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEB &  !RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[1]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEB &  !RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[0]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEB &  RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[31]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEB &  RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[30]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEB &  RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[29]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEB &  RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[28]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEB &  RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[27]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEB &  RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[26]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEB &  RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[25]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEB &  RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[24]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEB &  RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[23]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEB &  RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[22]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEB &  RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[21]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEB &  RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[20]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEB &  RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[19]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEB &  RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[18]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEB &  RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[17]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEB &  RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[16]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEB &  RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[15]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEB &  RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[14]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEB &  RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[13]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEB &  RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[12]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEB &  RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[11]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEB &  RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[10]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEB &  RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[9]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEB &  RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[8]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEB &  RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[7]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEB &  RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[6]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEB &  RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[5]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEB &  RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[4]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEB &  RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[3]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEB &  RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[2]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEB &  RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[1]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEB &  RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[0]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEB &  !RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[31]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEB &  !RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[30]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEB &  !RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[29]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEB &  !RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[28]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEB &  !RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[27]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEB &  !RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[26]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEB &  !RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[25]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEB &  !RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[24]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEB &  !RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[23]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEB &  !RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[22]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEB &  !RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[21]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEB &  !RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[20]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEB &  !RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[19]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEB &  !RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[18]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEB &  !RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[17]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEB &  !RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[16]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEB &  !RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[15]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEB &  !RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[14]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEB &  !RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[13]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEB &  !RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[12]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEB &  !RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[11]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEB &  !RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[10]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEB &  !RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[9]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEB &  !RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[8]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEB &  !RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[7]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEB &  !RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[6]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEB &  !RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[5]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEB &  !RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[4]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEB &  !RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[3]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEB &  !RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[2]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEB &  !RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[1]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEB &  !RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[0]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEB &  RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[31]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RMEB &  RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[30]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RMEB &  RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[29]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RMEB &  RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[28]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RMEB &  RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[27]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RMEB &  RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[26]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RMEB &  RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[25]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RMEB &  RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[24]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RMEB &  RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[23]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RMEB &  RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[22]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RMEB &  RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[21]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RMEB &  RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[20]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RMEB &  RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[19]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RMEB &  RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[18]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RMEB &  RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[17]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RMEB &  RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[16]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RMEB &  RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[15]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RMEB &  RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[14]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RMEB &  RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[13]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RMEB &  RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[12]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RMEB &  RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[11]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RMEB &  RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[10]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RMEB &  RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[9]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RMEB &  RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[8]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RMEB &  RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[7]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RMEB &  RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[6]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RMEB &  RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[5]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RMEB &  RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[4]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RMEB &  RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[3]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RMEB &  RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[2]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RMEB &  RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[1]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RMEB &  RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[0]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );

// Timing Checks

  $width (negedge CLKA, Tcl, 0, notif_clka);
  $width (posedge CLKA, Tch, 0, notif_clka);
  $period (posedge CLKA &&& ENCLKA_rmezo, Tcc, notif_clka);
  $period (negedge CLKA &&& ENCLKA_rmezo, Tcc, notif_clka);
  $period (posedge CLKA &&& ENCLKA_vdm, Tccvddmin, notif_clka);
  $period (negedge CLKA &&& ENCLKA_vdm, Tccvddmin, notif_clka);
  $period (posedge CLKA &&& ENCLKA_slw, Tccslow, notif_clka);
  $period (negedge CLKA &&& ENCLKA_slw, Tccslow, notif_clka);
  $period (posedge CLKA &&& ENCLKA_def, Tccdef, notif_clka);
  $period (negedge CLKA &&& ENCLKA_def, Tccdef, notif_clka);
  $period (posedge CLKA &&& ENCLKA_fst, Tccfast, notif_clka);
  $period (negedge CLKA &&& ENCLKA_fst, Tccfast, notif_clka);
  $width (negedge CLKB, Tcl, 0, notif_clkb);
  $width (posedge CLKB, Tch, 0, notif_clkb);
  $period (posedge CLKB &&& ENCLKB_rmezo, Tcc, notif_clkb);
  $period (negedge CLKB &&& ENCLKB_rmezo, Tcc, notif_clkb);
  $period (posedge CLKB &&& ENCLKB_vdm, Tccvddmin, notif_clkb);
  $period (negedge CLKB &&& ENCLKB_vdm, Tccvddmin, notif_clkb);
  $period (posedge CLKB &&& ENCLKB_slw, Tccslow, notif_clkb);
  $period (negedge CLKB &&& ENCLKB_slw, Tccslow, notif_clkb);
  $period (posedge CLKB &&& ENCLKB_def, Tccdef, notif_clkb);
  $period (negedge CLKB &&& ENCLKB_def, Tccdef, notif_clkb);
  $period (posedge CLKB &&& ENCLKB_fst, Tccfast, notif_clkb);
  $period (negedge CLKB &&& ENCLKB_fst, Tccfast, notif_clkb);
  $setuphold (posedge CLKA  &&& ENADRA, posedge ADRA[0], Tac, Tcax, notif_adra );
  $setuphold (posedge CLKA  &&& ENADRA, negedge ADRA[0], Tac, Tcax, notif_adra );
  $setuphold (posedge CLKA  &&& ENADRA, posedge ADRA[1], Tac, Tcax, notif_adra );
  $setuphold (posedge CLKA  &&& ENADRA, negedge ADRA[1], Tac, Tcax, notif_adra );
  $setuphold (posedge CLKA  &&& ENADRA, posedge ADRA[2], Tac, Tcax, notif_adra );
  $setuphold (posedge CLKA  &&& ENADRA, negedge ADRA[2], Tac, Tcax, notif_adra );
  $setuphold (posedge CLKA  &&& ENADRA, posedge ADRA[3], Tac, Tcax, notif_adra );
  $setuphold (posedge CLKA  &&& ENADRA, negedge ADRA[3], Tac, Tcax, notif_adra );
  $setuphold (posedge CLKA  &&& ENADRA, posedge ADRA[4], Tac, Tcax, notif_adra );
  $setuphold (posedge CLKA  &&& ENADRA, negedge ADRA[4], Tac, Tcax, notif_adra );
  $setuphold (posedge CLKA  &&& ENADRA, posedge ADRA[5], Tac, Tcax, notif_adra );
  $setuphold (posedge CLKA  &&& ENADRA, negedge ADRA[5], Tac, Tcax, notif_adra );
  $setuphold (posedge CLKA  &&& ENADRA, posedge ADRA[6], Tac, Tcax, notif_adra );
  $setuphold (posedge CLKA  &&& ENADRA, negedge ADRA[6], Tac, Tcax, notif_adra );
  $setuphold (posedge CLKA  &&& ENDA, posedge DA[0], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, negedge DA[0], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, posedge DA[1], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, negedge DA[1], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, posedge DA[2], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, negedge DA[2], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, posedge DA[3], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, negedge DA[3], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, posedge DA[4], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, negedge DA[4], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, posedge DA[5], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, negedge DA[5], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, posedge DA[6], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, negedge DA[6], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, posedge DA[7], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, negedge DA[7], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, posedge DA[8], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, negedge DA[8], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, posedge DA[9], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, negedge DA[9], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, posedge DA[10], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, negedge DA[10], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, posedge DA[11], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, negedge DA[11], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, posedge DA[12], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, negedge DA[12], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, posedge DA[13], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, negedge DA[13], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, posedge DA[14], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, negedge DA[14], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, posedge DA[15], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, negedge DA[15], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, posedge DA[16], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, negedge DA[16], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, posedge DA[17], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, negedge DA[17], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, posedge DA[18], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, negedge DA[18], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, posedge DA[19], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, negedge DA[19], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, posedge DA[20], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, negedge DA[20], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, posedge DA[21], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, negedge DA[21], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, posedge DA[22], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, negedge DA[22], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, posedge DA[23], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, negedge DA[23], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, posedge DA[24], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, negedge DA[24], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, posedge DA[25], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, negedge DA[25], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, posedge DA[26], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, negedge DA[26], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, posedge DA[27], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, negedge DA[27], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, posedge DA[28], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, negedge DA[28], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, posedge DA[29], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, negedge DA[29], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, posedge DA[30], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, negedge DA[30], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, posedge DA[31], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, negedge DA[31], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENWEA, posedge WEA,Twc, Tcwx, notif_wea );
  $setuphold (posedge CLKA  &&& ENWEA, negedge WEA,Twc, Tcwx, notif_wea );
  $setuphold (posedge CLKA  &&& ENMEA, posedge MEA,Tmc, Tcmx, notif_mea );
  $setuphold (posedge CLKA  &&& ENMEA, negedge MEA,Tmc, Tcmx, notif_mea );
  $hold (negedge CLKA  &&& ENTEST1A, posedge TEST1A, TCT1X, notif_test1a );
  $hold (negedge CLKA  &&& ENTEST1A, negedge TEST1A, TCT1X, notif_test1a );
  $setup ( posedge TEST1A,posedge CLKA  &&& ENTEST1A, TT1C, notif_test1a );
  $setup ( negedge TEST1A,posedge CLKA  &&& ENTEST1A, TT1C, notif_test1a );
  $setuphold (posedge CLKA  &&& ENRMEA, posedge RMEA,Trmec, Tcrmex, notif_rmea );
  $setuphold (posedge CLKA  &&& ENRMEA, negedge RMEA,Trmec, Tcrmex, notif_rmea );
  $setuphold (posedge CLKA  &&& ENRMA, posedge RMA[0], Trmc, Tcrmx, notif_rma );
  $setuphold (posedge CLKA  &&& ENRMA, negedge RMA[0], Trmc, Tcrmx, notif_rma );
  $setuphold (posedge CLKA  &&& ENRMA, posedge RMA[1], Trmc, Tcrmx, notif_rma );
  $setuphold (posedge CLKA  &&& ENRMA, negedge RMA[1], Trmc, Tcrmx, notif_rma );
  $setuphold (posedge CLKA  &&& ENRMA, posedge RMA[2], Trmc, Tcrmx, notif_rma );
  $setuphold (posedge CLKA  &&& ENRMA, negedge RMA[2], Trmc, Tcrmx, notif_rma );
  $setuphold (posedge CLKA  &&& ENRMA, posedge RMA[3], Trmc, Tcrmx, notif_rma );
  $setuphold (posedge CLKA  &&& ENRMA, negedge RMA[3], Trmc, Tcrmx, notif_rma );
  $setuphold (posedge CLKB  &&& ENADRB, posedge ADRB[0], Tac, Tcax, notif_adrb );
  $setuphold (posedge CLKB  &&& ENADRB, negedge ADRB[0], Tac, Tcax, notif_adrb );
  $setuphold (posedge CLKB  &&& ENADRB, posedge ADRB[1], Tac, Tcax, notif_adrb );
  $setuphold (posedge CLKB  &&& ENADRB, negedge ADRB[1], Tac, Tcax, notif_adrb );
  $setuphold (posedge CLKB  &&& ENADRB, posedge ADRB[2], Tac, Tcax, notif_adrb );
  $setuphold (posedge CLKB  &&& ENADRB, negedge ADRB[2], Tac, Tcax, notif_adrb );
  $setuphold (posedge CLKB  &&& ENADRB, posedge ADRB[3], Tac, Tcax, notif_adrb );
  $setuphold (posedge CLKB  &&& ENADRB, negedge ADRB[3], Tac, Tcax, notif_adrb );
  $setuphold (posedge CLKB  &&& ENADRB, posedge ADRB[4], Tac, Tcax, notif_adrb );
  $setuphold (posedge CLKB  &&& ENADRB, negedge ADRB[4], Tac, Tcax, notif_adrb );
  $setuphold (posedge CLKB  &&& ENADRB, posedge ADRB[5], Tac, Tcax, notif_adrb );
  $setuphold (posedge CLKB  &&& ENADRB, negedge ADRB[5], Tac, Tcax, notif_adrb );
  $setuphold (posedge CLKB  &&& ENADRB, posedge ADRB[6], Tac, Tcax, notif_adrb );
  $setuphold (posedge CLKB  &&& ENADRB, negedge ADRB[6], Tac, Tcax, notif_adrb );
  $setuphold (posedge CLKB  &&& ENDB, posedge DB[0], Tdc, Tcdx, notif_db );
  $setuphold (posedge CLKB  &&& ENDB, negedge DB[0], Tdc, Tcdx, notif_db );
  $setuphold (posedge CLKB  &&& ENDB, posedge DB[1], Tdc, Tcdx, notif_db );
  $setuphold (posedge CLKB  &&& ENDB, negedge DB[1], Tdc, Tcdx, notif_db );
  $setuphold (posedge CLKB  &&& ENDB, posedge DB[2], Tdc, Tcdx, notif_db );
  $setuphold (posedge CLKB  &&& ENDB, negedge DB[2], Tdc, Tcdx, notif_db );
  $setuphold (posedge CLKB  &&& ENDB, posedge DB[3], Tdc, Tcdx, notif_db );
  $setuphold (posedge CLKB  &&& ENDB, negedge DB[3], Tdc, Tcdx, notif_db );
  $setuphold (posedge CLKB  &&& ENDB, posedge DB[4], Tdc, Tcdx, notif_db );
  $setuphold (posedge CLKB  &&& ENDB, negedge DB[4], Tdc, Tcdx, notif_db );
  $setuphold (posedge CLKB  &&& ENDB, posedge DB[5], Tdc, Tcdx, notif_db );
  $setuphold (posedge CLKB  &&& ENDB, negedge DB[5], Tdc, Tcdx, notif_db );
  $setuphold (posedge CLKB  &&& ENDB, posedge DB[6], Tdc, Tcdx, notif_db );
  $setuphold (posedge CLKB  &&& ENDB, negedge DB[6], Tdc, Tcdx, notif_db );
  $setuphold (posedge CLKB  &&& ENDB, posedge DB[7], Tdc, Tcdx, notif_db );
  $setuphold (posedge CLKB  &&& ENDB, negedge DB[7], Tdc, Tcdx, notif_db );
  $setuphold (posedge CLKB  &&& ENDB, posedge DB[8], Tdc, Tcdx, notif_db );
  $setuphold (posedge CLKB  &&& ENDB, negedge DB[8], Tdc, Tcdx, notif_db );
  $setuphold (posedge CLKB  &&& ENDB, posedge DB[9], Tdc, Tcdx, notif_db );
  $setuphold (posedge CLKB  &&& ENDB, negedge DB[9], Tdc, Tcdx, notif_db );
  $setuphold (posedge CLKB  &&& ENDB, posedge DB[10], Tdc, Tcdx, notif_db );
  $setuphold (posedge CLKB  &&& ENDB, negedge DB[10], Tdc, Tcdx, notif_db );
  $setuphold (posedge CLKB  &&& ENDB, posedge DB[11], Tdc, Tcdx, notif_db );
  $setuphold (posedge CLKB  &&& ENDB, negedge DB[11], Tdc, Tcdx, notif_db );
  $setuphold (posedge CLKB  &&& ENDB, posedge DB[12], Tdc, Tcdx, notif_db );
  $setuphold (posedge CLKB  &&& ENDB, negedge DB[12], Tdc, Tcdx, notif_db );
  $setuphold (posedge CLKB  &&& ENDB, posedge DB[13], Tdc, Tcdx, notif_db );
  $setuphold (posedge CLKB  &&& ENDB, negedge DB[13], Tdc, Tcdx, notif_db );
  $setuphold (posedge CLKB  &&& ENDB, posedge DB[14], Tdc, Tcdx, notif_db );
  $setuphold (posedge CLKB  &&& ENDB, negedge DB[14], Tdc, Tcdx, notif_db );
  $setuphold (posedge CLKB  &&& ENDB, posedge DB[15], Tdc, Tcdx, notif_db );
  $setuphold (posedge CLKB  &&& ENDB, negedge DB[15], Tdc, Tcdx, notif_db );
  $setuphold (posedge CLKB  &&& ENDB, posedge DB[16], Tdc, Tcdx, notif_db );
  $setuphold (posedge CLKB  &&& ENDB, negedge DB[16], Tdc, Tcdx, notif_db );
  $setuphold (posedge CLKB  &&& ENDB, posedge DB[17], Tdc, Tcdx, notif_db );
  $setuphold (posedge CLKB  &&& ENDB, negedge DB[17], Tdc, Tcdx, notif_db );
  $setuphold (posedge CLKB  &&& ENDB, posedge DB[18], Tdc, Tcdx, notif_db );
  $setuphold (posedge CLKB  &&& ENDB, negedge DB[18], Tdc, Tcdx, notif_db );
  $setuphold (posedge CLKB  &&& ENDB, posedge DB[19], Tdc, Tcdx, notif_db );
  $setuphold (posedge CLKB  &&& ENDB, negedge DB[19], Tdc, Tcdx, notif_db );
  $setuphold (posedge CLKB  &&& ENDB, posedge DB[20], Tdc, Tcdx, notif_db );
  $setuphold (posedge CLKB  &&& ENDB, negedge DB[20], Tdc, Tcdx, notif_db );
  $setuphold (posedge CLKB  &&& ENDB, posedge DB[21], Tdc, Tcdx, notif_db );
  $setuphold (posedge CLKB  &&& ENDB, negedge DB[21], Tdc, Tcdx, notif_db );
  $setuphold (posedge CLKB  &&& ENDB, posedge DB[22], Tdc, Tcdx, notif_db );
  $setuphold (posedge CLKB  &&& ENDB, negedge DB[22], Tdc, Tcdx, notif_db );
  $setuphold (posedge CLKB  &&& ENDB, posedge DB[23], Tdc, Tcdx, notif_db );
  $setuphold (posedge CLKB  &&& ENDB, negedge DB[23], Tdc, Tcdx, notif_db );
  $setuphold (posedge CLKB  &&& ENDB, posedge DB[24], Tdc, Tcdx, notif_db );
  $setuphold (posedge CLKB  &&& ENDB, negedge DB[24], Tdc, Tcdx, notif_db );
  $setuphold (posedge CLKB  &&& ENDB, posedge DB[25], Tdc, Tcdx, notif_db );
  $setuphold (posedge CLKB  &&& ENDB, negedge DB[25], Tdc, Tcdx, notif_db );
  $setuphold (posedge CLKB  &&& ENDB, posedge DB[26], Tdc, Tcdx, notif_db );
  $setuphold (posedge CLKB  &&& ENDB, negedge DB[26], Tdc, Tcdx, notif_db );
  $setuphold (posedge CLKB  &&& ENDB, posedge DB[27], Tdc, Tcdx, notif_db );
  $setuphold (posedge CLKB  &&& ENDB, negedge DB[27], Tdc, Tcdx, notif_db );
  $setuphold (posedge CLKB  &&& ENDB, posedge DB[28], Tdc, Tcdx, notif_db );
  $setuphold (posedge CLKB  &&& ENDB, negedge DB[28], Tdc, Tcdx, notif_db );
  $setuphold (posedge CLKB  &&& ENDB, posedge DB[29], Tdc, Tcdx, notif_db );
  $setuphold (posedge CLKB  &&& ENDB, negedge DB[29], Tdc, Tcdx, notif_db );
  $setuphold (posedge CLKB  &&& ENDB, posedge DB[30], Tdc, Tcdx, notif_db );
  $setuphold (posedge CLKB  &&& ENDB, negedge DB[30], Tdc, Tcdx, notif_db );
  $setuphold (posedge CLKB  &&& ENDB, posedge DB[31], Tdc, Tcdx, notif_db );
  $setuphold (posedge CLKB  &&& ENDB, negedge DB[31], Tdc, Tcdx, notif_db );
  $setuphold (posedge CLKB  &&& ENWEB, posedge WEB,Twc, Tcwx, notif_web );
  $setuphold (posedge CLKB  &&& ENWEB, negedge WEB,Twc, Tcwx, notif_web );
  $setuphold (posedge CLKB  &&& ENMEB, posedge MEB,Tmc, Tcmx, notif_meb );
  $setuphold (posedge CLKB  &&& ENMEB, negedge MEB,Tmc, Tcmx, notif_meb );
  $hold (negedge CLKB  &&& ENTEST1B, posedge TEST1B, TCT1X, notif_test1b );
  $hold (negedge CLKB  &&& ENTEST1B, negedge TEST1B, TCT1X, notif_test1b );
  $setup ( posedge TEST1B,posedge CLKB  &&& ENTEST1B, TT1C, notif_test1b );
  $setup ( negedge TEST1B,posedge CLKB  &&& ENTEST1B, TT1C, notif_test1b );
  $setuphold (posedge CLKB  &&& ENRMEB, posedge RMEB,Trmec, Tcrmex, notif_rmeb );
  $setuphold (posedge CLKB  &&& ENRMEB, negedge RMEB,Trmec, Tcrmex, notif_rmeb );
  $setuphold (posedge CLKB  &&& ENRMB, posedge RMB[0], Trmc, Tcrmx, notif_rmb );
  $setuphold (posedge CLKB  &&& ENRMB, negedge RMB[0], Trmc, Tcrmx, notif_rmb );
  $setuphold (posedge CLKB  &&& ENRMB, posedge RMB[1], Trmc, Tcrmx, notif_rmb );
  $setuphold (posedge CLKB  &&& ENRMB, negedge RMB[1], Trmc, Tcrmx, notif_rmb );
  $setuphold (posedge CLKB  &&& ENRMB, posedge RMB[2], Trmc, Tcrmx, notif_rmb );
  $setuphold (posedge CLKB  &&& ENRMB, negedge RMB[2], Trmc, Tcrmx, notif_rmb );
  $setuphold (posedge CLKB  &&& ENRMB, posedge RMB[3], Trmc, Tcrmx, notif_rmb );
  $setuphold (posedge CLKB  &&& ENRMB, negedge RMB[3], Trmc, Tcrmx, notif_rmb );
  $recovery ( posedge CLKA,posedge CLKB  &&& ENCLKACLKBrec, Tcsep, notif_clka_CLKB_rise_rise_rec);
  $recovery ( posedge CLKB,posedge CLKA  &&& ENCLKBCLKArec, Tcsep, notif_clkb_CLKA_rise_rise_rec);

endspecify
`endif // endif of VIRAGE_FAST_VERILOG

`ifdef VIRAGE_FAST_VERILOG
generic_behav_ram128x32_2p2r2w #( PreloadFilename, MES_ALL) u0 (  .QA (QA_buf), .QB (QB_buf), .ADRA (ADRA_buf), .DA (DA_buf), .WEA(WEA_buf), .MEA(MEA_buf), .CLKA(CLKA_buf), .TEST1A(TEST1A_buf), .RMEA(RMEA_buf), .RMA (RMA_int), .ADRB (ADRB_buf), .DB (DB_buf), .WEB(WEB_buf), .MEB(MEB_buf), .CLKB(CLKB_buf), .TEST1B(TEST1B_buf), .RMEB(RMEB_buf), .RMB (RMB_int), .sim_check_A (sim_check_A), .sim_check_B (sim_check_B) );
`else
generic_behav_ram128x32_2p2r2w #( PreloadFilename, MES_ALL) u0 (  .QA (QA_buf), .QB (QB_buf), .ADRA (ADRA_buf), .DA (DA_buf), .WEA(WEA_buf), .MEA(MEA_buf), .CLKA(CLKA_buf), .TEST1A(TEST1A_buf), .RMEA(RMEA_buf), .RMA (RMA_int), .ADRB (ADRB_buf), .DB (DB_buf), .WEB(WEB_buf), .MEB(MEB_buf), .CLKB(CLKB_buf), .TEST1B(TEST1B_buf), .RMEB(RMEB_buf), .RMB (RMB_int), .EVENT_TCQ_A (EVENT_TCQ_A), .EVENT_TCQ_B (EVENT_TCQ_B),.notif_adra(notif_adra), .notif_da(notif_da), .notif_wea(notif_wea), .notif_mea(notif_mea), .notif_clka(notif_clka), .notif_clka_CLKB_rise_rise_rec(notif_clka_CLKB_rise_rise_rec), .notif_test1a(notif_test1a), .notif_rmea(notif_rmea), .notif_rma(notif_rma), .notif_adrb(notif_adrb), .notif_db(notif_db), .notif_web(notif_web), .notif_meb(notif_meb), .notif_clkb(notif_clkb), .notif_clkb_CLKA_rise_rise_rec(notif_clkb_CLKA_rise_rise_rec), .notif_test1b(notif_test1b), .notif_rmeb(notif_rmeb), .notif_rmb(notif_rmb) );
`endif // endif of VIRAGE_FAST_VERILOG

initial
begin
  ADRFLAGA = 1;
  ADRFLAGB = 1;
end // end of initial block
always @( ADRA_buf or negedge CLKA_buf)
begin : blk_adrzerohold_0
  if ( CLKA_buf == 1'b0)
    ADRA_old = ADRA_buf;
end // end of always block blk_adrzerohold_0

always @( MEA_buf or negedge CLKA_buf)
begin : blk_mezerohold_0
  if ( CLKA_buf == 1'b0)
    MEA_old = MEA_buf;
end

always @( WEA_buf or negedge CLKA_buf)
begin : blk_wezerohol_0
  if ( CLKA_buf == 1'b0)
    WEA_old = WEA_buf;
end
always @( posedge CLKA_buf)
begin : blk_posclock_0
  MEA_buf_L = MEA_old;
  WEA_buf_L = WEA_old;
  CLK_T_A = $realtime;
`ifdef VIRAGE_FAST_VERILOG
`else
  EVENT_TCQ_A = 1'b1;
`endif
  ADRA_buf_L = ADRA_old;
  #0;
  if (CLK_T_A == CLK_T_B)
  begin
    if ( ((ADRA_buf_L === ADRB_buf_L) && ADRFLAGA) || (CLKA_buf === 1'bx || CLKB_buf === 1'bx) || (( ADRA_buf_L^ADRA_buf_L) !== 0) || (( ADRB_buf_L^ADRB_buf_L) !== 0))
    begin
      if ( (MEA_buf_L !== 1'b0 && MEB_buf_L !== 1'b0 ) && ((WEA_buf_L !== 1'b0) || (WEB_buf_L !== 1'b0) || ((WEA_buf_L !== 1'b0) && ( WEB_buf_L !== 1'b0 ))))
      begin
        `ifdef VIRAGE_FAST_VERILOG
        `else
        if( MES_ALL=="ON" && $realtime != 0 && u0.mes_all_valid)
        begin
          $display("<<VIRL_MEM_WARNING: Recovery Timing Violation on posedge CLKA wrt posedge CLKB>> at time=%t; instance=%m (RAMS1H)",$realtime);
        end // if of message display is enabled
        `endif // endif of VIRAGE_FAST_VERILOG
        `ifdef VIRAGE_FAST_VERILOG
        if( sim_check_A === 1'bx)
          #0 sim_check_A = 1'b0;
        else
          #0 sim_check_A = !sim_check_A;
        `else
        if(notif_clka_CLKB_rise_rise_rec === 1'bx)
          #0 notif_clka_CLKB_rise_rise_rec = 1'b0;
        else
         #0 notif_clka_CLKB_rise_rise_rec = !notif_clka_CLKB_rise_rise_rec;
        `endif // endif of VIRAGE_FAST_VERILOG
      end
    end
  end
end
always @( ADRB_buf or negedge CLKB_buf)
begin : blk_adrzerohold_1
  if ( CLKB_buf == 1'b0)
    ADRB_old = ADRB_buf;
end // end of always block blk_adrzerohold_1

always @( MEB_buf or negedge CLKB_buf)
begin : blk_mezerohold_1
  if ( CLKB_buf == 1'b0)
    MEB_old = MEB_buf;
end

always @( WEB_buf or negedge CLKB_buf)
begin : blk_wezerohol_1
  if ( CLKB_buf == 1'b0)
    WEB_old = WEB_buf;
end
always @( posedge CLKB_buf)
begin : blk_posclock_1
  MEB_buf_L = MEB_old;
  WEB_buf_L = WEB_old;
  CLK_T_B = $realtime;
`ifdef VIRAGE_FAST_VERILOG
`else
  EVENT_TCQ_B = 1'b1;
`endif
  ADRB_buf_L = ADRB_old;
  #0;
  if (CLK_T_B == CLK_T_A)
  begin
    if ( ((ADRB_buf_L === ADRA_buf_L) && ADRFLAGB) || (CLKB_buf === 1'bx || CLKA_buf === 1'bx) || (( ADRB_buf_L^ADRB_buf_L) !== 0) || (( ADRA_buf_L^ADRA_buf_L) !== 0))
    begin
      if ( (MEB_buf_L !== 1'b0 && MEA_buf_L !== 1'b0 ) && ((WEA_buf_L !== 1'b0) || (WEB_buf_L !== 1'b0) || ((WEA_buf_L !== 1'b0) && ( WEB_buf_L !== 1'b0 ))))
      begin
        `ifdef VIRAGE_FAST_VERILOG
        `else
        if( MES_ALL=="ON" && $realtime != 0 && u0.mes_all_valid)
        begin
          $display("<<VIRL_MEM_WARNING: Recovery Timing Violation on posedge CLKB wrt posedge CLKA>> at time=%t; instance=%m (RAMS1H)",$realtime);
        end // if of message display is enabled
        `endif // endif of VIRAGE_FAST_VERILOG
        `ifdef VIRAGE_FAST_VERILOG
        if( sim_check_B === 1'bx)
          #0 sim_check_B = 1'b0;
        else
          #0 sim_check_B = !sim_check_B;
        `else
        if(notif_clkb_CLKA_rise_rise_rec === 1'bx)
          #0 notif_clkb_CLKA_rise_rise_rec = 1'b0;
        else
         #0 notif_clkb_CLKA_rise_rise_rec = !notif_clkb_CLKA_rise_rise_rec;
        `endif // endif of VIRAGE_FAST_VERILOG
      end
    end
  end
end
`ifdef VIRAGE_FAST_VERILOG
`else
assign rise_time_same = ( CLK_T_A == CLK_T_B )? 1'b0:1'b1;
`endif


always @ ( ADRA_buf )
begin : blk_address_0
  if ( $realtime != 0)
  begin
    if ( ADRA_buf > 7'b1111111) 
    begin
      ADRFLAGA = 0;
    end // if of address is out of range
    else
    begin
      ADRFLAGA = 1;
    end // else of if address is out of range
  end // if of $realtime != 0
end // end of always block blk_address_0

always @ ( ADRB_buf )
begin : blk_address_1
  if ( $realtime != 0)
  begin
    if ( ADRB_buf > 7'b1111111) 
    begin
      ADRFLAGB = 0;
    end // if of address is out of range
    else
    begin
      ADRFLAGB = 1;
    end // else of if address is out of range
  end // if of $realtime != 0
end // end of always block blk_address_1

assign RMA_int = ((RMEA_buf===1'b1)?RMA_buf:((RMEA_buf===1'b0)?4'b0010:4'bx));
always @(posedge CLKA_buf )
begin : blk_posclock1_0
  if(RMEA_buf === 1'bx && MEA_buf === 1'b1)
  begin
    u0.report_unknown("RMEA");
    if ( WEA_buf == 1'b0 )
    begin
      u0.flaga_read_ok = `False;
      -> u0.ev_read_out_a_port;
    end // if of WEA_buf = 0
    u0.flaga_d_ok = `False;
    u0.checkSanityOnAport;
  end // if of RMEA_buf = X and MEA_buf = 1
end // end of always block blk_posclock1_0
assign RMB_int = ((RMEB_buf===1'b1)?RMB_buf:((RMEB_buf===1'b0)?4'b0010:4'bx));
always @(posedge CLKB_buf )
begin : blk_posclock1_1
  if(RMEB_buf === 1'bx && MEB_buf === 1'b1)
  begin
    u0.report_unknown("RMEB");
    if ( WEB_buf == 1'b0 )
    begin
      u0.flagb_read_ok = `False;
      -> u0.ev_read_out_b_port;
    end // if of WEB_buf = 0
    u0.flagb_d_ok = `False;
    u0.checkSanityOnAport;
  end // if of RMEB_buf = X and MEB_buf = 1
end // end of always block blk_posclock1_1


endmodule
`endcelldefine 
`ifdef verifault 
`disable_portfaults 
`nosuppress_faults 
`endif 


`ifdef VIRAGE_FAST_VERILOG
module generic_behav_ram128x32_2p2r2w (  QA, QB, ADRA, DA, WEA, MEA, CLKA, TEST1A, RMEA, RMA, ADRB, DB, WEB, MEB, CLKB, TEST1B, RMEB, RMB,sim_check_A, sim_check_B );
`else
module generic_behav_ram128x32_2p2r2w (  QA, QB, ADRA, DA, WEA, MEA, CLKA, TEST1A, RMEA, RMA, ADRB, DB, WEB, MEB, CLKB, TEST1B, RMEB, RMB, EVENT_TCQ_A, EVENT_TCQ_B,notif_adra, notif_da, notif_wea, notif_mea, notif_clka, notif_clka_CLKB_rise_rise_rec, notif_test1a, notif_rmea, notif_rma, notif_adrb, notif_db, notif_web, notif_meb, notif_clkb, notif_clkb_CLKA_rise_rise_rec, notif_test1b, notif_rmeb, notif_rmb );
`endif // endif of VIRAGE_FAST_VERILOG

parameter PreloadFilename = "init.file";
parameter MES_ALL = "ON";
parameter words = 128, bits = 32, addrbits = 7, O_delay=0.0, timingmode = 1, rmbits=4;

output [bits-1:0] QA;
output [bits-1:0] QB;
input [addrbits-1:0] ADRA;
input [bits-1:0] DA;
input WEA;
input MEA;
input CLKA;
input TEST1A;
input RMEA;
input [rmbits-1:0] RMA;
input [addrbits-1:0] ADRB;
input [bits-1:0] DB;
input WEB;
input MEB;
input CLKB;
input TEST1B;
input RMEB;
input [rmbits-1:0] RMB;

`ifdef VIRAGE_FAST_VERILOG
input sim_check_A, sim_check_B;
`else
input EVENT_TCQ_A;
input EVENT_TCQ_B;
input notif_adra, notif_da, notif_wea, notif_mea, notif_clka, notif_clka_CLKB_rise_rise_rec, notif_test1a, notif_rmea, notif_rma, notif_adrb, notif_db, notif_web, notif_meb, notif_clkb, notif_clkb_CLKA_rise_rise_rec, notif_test1b, notif_rmeb, notif_rmb;

`endif // endif of VIRAGE_FAST_VERILOG

parameter DataX = { bits { 1'bx } };
parameter DataZ = { bits { 1'bz } };

reg  [bits-1:0]  QA;
reg  [bits-1:0]  QB;
reg [addrbits-1:0] ADRAlatched;

reg [addrbits-1:0] ADRA_old;

reg [bits-1:0] DAlatched;

reg [bits-1:0] DA_old;

reg WEAlatched;
reg WEA_old;
reg MEAlatched;
reg MEA_old;
reg TEST1Alatched;
reg TEST1A_old;
reg [addrbits-1:0] ADRBlatched;

reg [addrbits-1:0] ADRB_old;

reg [bits-1:0] DBlatched;

reg [bits-1:0] DB_old;

reg WEBlatched;
reg WEB_old;
reg MEBlatched;
reg MEB_old;
reg TEST1Blatched;
reg TEST1B_old;
//reg  [bits-1:0] X_a_corrupt;
reg
  flaga_read_ok,
  flaga_we_ok,
  flaga_d_ok,
  flaga_rm_ok,
  flaga_adr_ok,
  flaga_range_ok;
reg     flaga_clk_valid;
reg     flaga_viol;
event   ev_read_out_a_port;
event   ev_RST_out_a_port;
reg  MEA_chk;
real CLKA_TIME;
real CLKA_T;
wire   [31:0]  QA_temp;
reg    [31:0]  QA_local_tmp;
reg
  flagb_read_ok,
  flagb_we_ok,
  flagb_d_ok,
  flagb_rm_ok,
  flagb_adr_ok,
  flagb_range_ok;
reg     flagb_clk_valid;
reg     flagb_viol;
event   ev_read_out_b_port;
event   ev_RST_out_b_port;
reg  MEB_chk;
real CLKB_TIME;
real CLKB_T;
wire   [31:0]  QB_temp;
reg    [31:0]  QB_local_tmp;
`ifdef VIRAGE_FAST_VERILOG
`else
real tcqa_time;

always @(negedge EVENT_TCQ_A)
begin : blk_negtcqevent_0
  tcqa_time = $realtime;
end // end of always block blk_negtcqevent_0
`endif // endif of VIRAGE_FAST_VERILOG
reg mes_all_valid;
integer i;
reg  [bits-1:0] mem_core_array [0:words -1];
reg[ 31:0] mem_core_array_read [0:127];
reg [bits - 1:0] mem_core_rowA;

reg  [bits-1:0] mem_fault_array_XOR [0:words -1];
initial
begin
  for (i=0; i< words ; i=i+1)
    mem_fault_array_XOR[i]=0;
  `ifdef MEMFAULTINJ
  if ($test$plusargs("asap_error"))
  begin
    mem_fault_array_XOR[1] = 1'b1 << (bits - 1);
  end // if of +asap_error is used
  `endif
end

integer load_mem_cnt;
integer bit_cntA;
`ifdef VIRAGE_FAST_VERILOG
`else
real tcqb_time;

always @(negedge EVENT_TCQ_B)
begin : blk_negtcqevent_1
  tcqb_time = $realtime;
end // end of always block blk_negtcqevent_1
`endif // endif of VIRAGE_FAST_VERILOG

integer bit_cntB;


// Checks whether address input is Valid; 1-bit return value
function is_adr_Valid;  
input [addrbits-1:0] addr_to_check;
reg     ret_value;
begin
  ret_value = `True;
  if ((^addr_to_check) === 1'bx)
  begin
    ret_value = `False;
  end // if addr_to_check is X
  is_adr_Valid = ret_value;
end
endfunction

// Checks whether any bit of input is X; 1-bit return value
function is_x;  
input [bits-1:0] addr_to_check;
reg     ret_value;
begin
  ret_value = `False;
  if ((^addr_to_check) === 1'bx) 
  begin
    ret_value = `True;
  end // if of addr_to_check = X
  is_x = ret_value;
end
endfunction

// -------------------------------------------------------------------
// Common tasks
// -------------------------------------------------------------------

// Task to report unknown messages
task report_unknown;
input [8*6:1] signal;
begin
    if( MES_ALL=="ON" && $realtime != 0 && mes_all_valid )
    begin
      $display("<<%0s unknown>> at time=%t; instance=%m (RAMS1H)",signal,$realtime);
    end
end
endtask


// Corrupt Current Location
task corrupt_cur_loc;
input[6:0] Adr_to_corrupt;
integer cnt;
begin
  if (is_adr_Valid (Adr_to_corrupt))
  begin
    mem_core_array[Adr_to_corrupt] = 32'bx;
  end // if of is_adr_Valid (Adr_to_corrupt)
  else
  begin
      corrupt_all_loc(`True);
  end // else of if is_adr_Valid (Adr_to_corrupt)
end
endtask

// Corrupt Entire memory; Do not corrupt entire memory if address is out of range
// during Write; For all other cases, if flag_range_ok is true, corrupt entire memory
task corrupt_all_loc;
input flag_range_ok;
integer row_index;
begin
  if( flag_range_ok == `True)
  begin
    for( row_index = 0; row_index < words ; row_index = row_index + 1)
    begin
      mem_core_array[row_index] = 32'bx;
    end // end of for row_index loop
  end // if of flag_range_ok is true
end
endtask

// Check whether rm pin is valid or not
function is_rm_Valid;
input [rmbits-1:0] rm_to_chk;
reg ret_val;
begin
  ret_val = `True;
  if ((^rm_to_chk === 1'bx))
  begin
    ret_val = `False;
  end // if of rm_to_chk = X
  is_rm_Valid = ret_val;
end 
endfunction


// Perform Sanity Check on Port A, Corrupt memory if required

task checkSanityOnAport;
begin

  #0                // let CLOCK and NOTIFIER stuff execute first
  case ( {flaga_adr_ok, flaga_we_ok, flaga_d_ok} ) // only 1 and 0
    3'b111   : ;                                                // everything ok!!!
    3'b101,
    3'b100   : corrupt_cur_loc(ADRAlatched);          // WE is unstable
    3'b110   : if (WEAlatched !== 1'b0)
                 corrupt_cur_loc(ADRAlatched);         // Data is unstable
    3'b000,
    3'b001   : corrupt_all_loc(flaga_range_ok);            // ADR and WE unstable
    3'b010,
    3'b011   : corrupt_all_loc(flaga_range_ok);    // ADR unstable, WE stable
  endcase
    flaga_adr_ok = `True;
    flaga_we_ok  = `True;
    flaga_d_ok  = `True;
 end
endtask // end of task checkSanityOnAport

// PORT A FUNCTIONALITY (Handle violation behavior)

reg INTERNAL_RESET; // For Internally resetting the memory(negedge of rscrst)

initial
begin
  mes_all_valid = 1'b0;
  flaga_adr_ok  = `True;
  flaga_range_ok = `True;
  flaga_we_ok   = `True;
  flaga_d_ok    = `True;
  flaga_read_ok = `True;
  flaga_rm_ok = `True;
  flaga_viol = `False;
  flaga_clk_valid = `True;
  `ifdef VIRAGE_IGNORE_RESET
  INTERNAL_RESET = 1'b0;
  #1 INTERNAL_RESET = 1'b1;
  #1 INTERNAL_RESET = 1'b0;
  `else
  `endif // endif of VIRAGE_IGNORE_RESET
end // end of initial block

// Perform Sanity Check on Port B, Corrupt memory if required

task checkSanityOnBport;
begin

  #0                // let CLOCK and NOTIFIER stuff execute first
  case ( {flagb_adr_ok, flagb_we_ok, flagb_d_ok} ) // only 1 and 0
    3'b111   : ;                                                // everything ok!!!
    3'b101,
    3'b100   : corrupt_cur_loc(ADRBlatched);          // WE is unstable
    3'b110   : if (WEBlatched !== 1'b0)
                 corrupt_cur_loc(ADRBlatched);         // Data is unstable
    3'b000,
    3'b001   : corrupt_all_loc(flagb_range_ok);            // ADR and WE unstable
    3'b010,
    3'b011   : corrupt_all_loc(flagb_range_ok);    // ADR unstable, WE stable
  endcase
    flagb_adr_ok = `True;
    flagb_we_ok  = `True;
    flagb_d_ok  = `True;
 end
endtask // end of task checkSanityOnBport

// PORT B FUNCTIONALITY (Handle violation behavior)


initial
begin
  mes_all_valid = 1'b0;
  flagb_adr_ok  = `True;
  flagb_range_ok = `True;
  flagb_we_ok   = `True;
  flagb_d_ok    = `True;
  flagb_read_ok = `True;
  flagb_rm_ok = `True;
  flagb_viol = `False;
  flagb_clk_valid = `True;
end // end of initial block

// For Zerohold of ADRA pin
always @( negedge CLKA or ADRA )
begin : blk_addrhold_0
  if ( CLKA == 1'b0 )
  begin
    ADRA_old = ADRA;
  end // if of CLKA = 0
end // end of always block blk_addrhold_0
// For Zerohold of DA pin
always @( negedge CLKA or DA )
begin : blk_dihold_0
  if ( CLKA == 1'b0 )
  begin
    DA_old = DA;
  end // if of CLKA = 0
end // end of always block blk_dihold_0
// For Zerohold of WEA pin
always @( negedge CLKA or WEA )
begin : blk_wehold_0
  if ( CLKA == 1'b0 )
  begin
    WEA_old = WEA;
  end // if of CLKA = 0
end // end of always block blk_wehold_0
// For Zerohold of MEA pin
always @( negedge CLKA or MEA )
begin : blk_mehold_0
  if ( CLKA == 1'b0 )
  begin
    MEA_old = MEA;
  end // if of CLKA = 0
end // end of always block blk_mehold_0
// For Zerohold of Test1 pin
always @( negedge CLKA or TEST1A )
begin : blk_test1hold_0
  if ( CLKA == 1'b0 )
  begin
    TEST1A_old = TEST1A;
  end // if of CLKA = 0
end // end of always block blk_test1hold_0

// For Zerohold of ADRB pin
always @( negedge CLKB or ADRB )
begin : blk_addrhold_1
  if ( CLKB == 1'b0 )
  begin
    ADRB_old = ADRB;
  end // if of CLKB = 0
end // end of always block blk_addrhold_1
// For Zerohold of DB pin
always @( negedge CLKB or DB )
begin : blk_dihold_1
  if ( CLKB == 1'b0 )
  begin
    DB_old = DB;
  end // if of CLKB = 0
end // end of always block blk_dihold_1
// For Zerohold of WEB pin
always @( negedge CLKB or WEB )
begin : blk_wehold_1
  if ( CLKB == 1'b0 )
  begin
    WEB_old = WEB;
  end // if of CLKB = 0
end // end of always block blk_wehold_1
// For Zerohold of MEB pin
always @( negedge CLKB or MEB )
begin : blk_mehold_1
  if ( CLKB == 1'b0 )
  begin
    MEB_old = MEB;
  end // if of CLKB = 0
end // end of always block blk_mehold_1
// For Zerohold of Test1 pin
always @( negedge CLKB or TEST1B )
begin : blk_test1hold_1
  if ( CLKB == 1'b0 )
  begin
    TEST1B_old = TEST1B;
  end // if of CLKB = 0
end // end of always block blk_test1hold_1


`ifdef VIRAGE_FAST_VERILOG
`else
// PORT A WE violation
always @(notif_wea)           
begin : blk_notif_we_0
    if ( WEA_old === 1'b0)
    begin
      flaga_viol = `True;
    end // if of WEA_old = 0
    flaga_we_ok = `False;
    checkSanityOnAport;
    flaga_read_ok = `False;
    -> ev_read_out_a_port;
end // end of always block blk_notif_we_0

// PORT A CLK violation
always @(notif_clka)
begin : blk_notif_clk_0
  flaga_clk_valid = `False;
  MEB_chk = MEB_old;
  if ( EVENT_TCQ_B == 1'b1 && MEB_chk === 1'b1 )
  begin
    disable blk_readout_1.OUTPUT_b;
    flagb_read_ok = `False;
    -> ev_read_out_b_port;
  end 
  flaga_adr_ok = `False;
  flaga_we_ok  = `False;
  checkSanityOnAport;
  flaga_read_ok = `False;     // irrespective of WE
  -> ev_read_out_a_port;
end // end of always block blk_notif_clk_0

// PORT A ME violation
always @(notif_mea)           
begin : blk_notif_me_0
  if (((WEAlatched === 1'b1)) && (EVENT_TCQ_B == 1'b1 || (tcqb_time == $realtime)))
  begin
    disable blk_readout_1.OUTPUT_b;
    flagb_read_ok = `False;
    -> ev_read_out_b_port;
  end // if of write
    flaga_viol = `True;
    flaga_read_ok = `False;                           
    -> ev_read_out_a_port;
    flaga_adr_ok = `False;
    checkSanityOnAport;
end // end of always block blk_notif_me_0

// PORT A ADR violation
always @(notif_adra)     
begin : blk_notif_addr_0
   MEB_chk = MEB_old;
   if (MEB_chk === 1'b1 && ((WEAlatched === 1'b1)) && (EVENT_TCQ_B == 1'b1 || (tcqb_time == $realtime)))
    begin
      disable blk_readout_1.OUTPUT_b;
      flagb_read_ok = `False;
      -> ev_read_out_b_port;
    end // if of write
      flaga_viol = `True;
      flaga_read_ok = `False;                         
      -> ev_read_out_a_port;
      flaga_adr_ok = `False;
      corrupt_all_loc(`True);
end // end of always block blk_notif_addr_0

// PORT A D violation
always @(notif_da)     
begin : blk_notif_di_0
    flaga_viol = `True;
    flaga_read_ok = `False;
    -> ev_read_out_a_port;
    flaga_d_ok = `False;
    checkSanityOnAport;
end // end of always block blk_notif_di_0

//PORT A TEST1 violation
always @(notif_test1a)   
begin : blk_notif_test1_0
//  MEA_chk = MEA_old;
    flaga_viol = `True;
    flaga_read_ok = `False;
    -> ev_read_out_a_port;
    flaga_d_ok  = `False;
    checkSanityOnAport;
end // end of always block blk_notif_test1_0

//PORT A RM violation
always @(notif_rma)       
begin : blk_notif_rm_0
    flaga_viol = `True;
    flaga_read_ok = `False;
    -> ev_read_out_a_port;
    flaga_d_ok  = `False;
    checkSanityOnAport;
end // end of always block blk_notif_rm_0

//PORT A RME violation
always @(notif_rmea)  
begin : blk_notif_rmen_0
    flaga_viol = `True;
    flaga_read_ok = `False;
    -> ev_read_out_a_port;
    flaga_d_ok  = `False;
    checkSanityOnAport;
end // end of always block blk_notif_rmen_0


`endif // endif of VIRAGE_FAST_VERILOG

// Simultaneous Clock Handling
`ifdef VIRAGE_FAST_VERILOG
always @(sim_check_A)
begin : blk_simultclock_0
`else
always @(notif_clka_CLKB_rise_rise_rec)
begin : blk_simultclock_0
`endif // endif of VIRAGE_FAST_VERILOG
      if ( WEAlatched !== 1'b0 && WEB_old  !== 1'b0 )
      begin
        flaga_d_ok = `False;
        flagb_d_ok = `False;
        checkSanityOnAport;           // corrupt current location
      end // if write enable is not disabled for both ports
      else if ( WEAlatched !== 1'b0)
      begin
        #0;
        flagb_viol = `True;
        flagb_read_ok = `False;
        -> ev_read_out_b_port;
      end // else if of WEAlatched != 0
      else 
      begin
        flaga_read_ok = `False;
        -> ev_read_out_a_port;
      end // else if of WEB_old  != 0
end // end of always block blk_simultclock_0

`ifdef VIRAGE_FAST_VERILOG
`else
`endif // endif of VIRAGE_FAST_VERILOG

// reset for next cycle

always @(negedge CLKA)
begin : blk_intnegclock_0
  if (flaga_clk_valid)
  begin
    flaga_adr_ok  = `True;
    flaga_we_ok   = `True;
    flaga_d_ok    = `True;
    flaga_viol    = `False;
  end // if of flaga_clk_valid is true
  if ( CLKA !== 1'bx )
  begin
    #0.001;
    flaga_range_ok  = `True;
    flaga_read_ok = `True;
    flaga_rm_ok = `True;
    flaga_clk_valid = `True;
  end // if of CLKA != X
  else
  begin
    flaga_clk_valid = `False;
    QA_local_tmp = 32'bx;
    corrupt_all_loc(`True);
    report_unknown("CLKA");
  end // else of if CLKA != X
end // end of always block blk_intnegclock_0

// PORT A FUNCTIONALITY 


always @(posedge CLKA)
begin : blk_intposclock_0
  CLKA_T = $realtime;
  MEAlatched = MEA_old;
  WEAlatched = WEA_old;
  TEST1Alatched = TEST1A_old;
  ADRAlatched = ADRA_old;
  DAlatched = DA_old;
  if (is_x(ADRAlatched) == `True && MEAlatched !== 1'b0)
  begin
    report_unknown("ADRA");
    if ( WEAlatched === 1'b1 )
    begin
      flaga_viol = `True;
    end // if of WEAlatched = 1
    else
    begin
      flaga_read_ok = `False;
    end
    `ifdef virage_ignore_read_addx
    if ((WEAlatched === 1'b1))
    begin
      flaga_adr_ok = `False;
      corrupt_all_loc(flaga_range_ok);
    end // if of write
    `else
    flaga_adr_ok = `False;
    corrupt_all_loc(flaga_range_ok);
    `endif // endif of virage_ignore_read_addx is true
    -> ev_RST_out_a_port;
  end // if of is_x(ADRAlatched) is true and MEAlatched != 0
  else if((ADRAlatched > 7'b1111111) && (MEAlatched === 1'b1) && (WEAlatched === 1'b1) )
  begin
    $display("\n%m VIRL_MEM_WARNING:address is out of range\n RANGE: 0 to 127\n");
    flaga_range_ok = `False;
  end // if of ADRAlatched out of range with MEAlatched = 1
  else
  begin
  end // else of if is_x(ADRAlatched) is true and MEAlatched != 0
  if (!flaga_clk_valid) 
  begin
    QA_local_tmp = 32'bx;
  end // if of flaga_clk_valid is NOT true
  else if ( CLKA === 1'bx )
  begin
    QA_local_tmp = 32'bx;
    corrupt_all_loc(flaga_range_ok);
    report_unknown("CLKA");
  end // if of CLKA = X
  else
  begin
      -> ev_RST_out_a_port;
  end // else of if CLKA = X
end // end of always block blk_intposclock_0
// PORT A READ-OUT

always @(ev_read_out_a_port)
begin : blk_readout_0
  #0                // let CLOCK and NOTIFIER module execute first
  if (RMEA === 1'b1)
  begin
    if (RMA >= 4'b0100)
    begin
      if( MES_ALL=="ON" && $realtime != 0)
      begin
      $display("RMA = %b is not recommended value at time=%t; instance=%m (RAMS1H)",RMA,$realtime);
      end
    end
  end
  else
  begin
  if (RMA != 4'b0010)
  begin
    if( MES_ALL=="ON" && $realtime != 0)
    begin
      $display("RMA = %b is not recommended value at time=%t; instance=%m (RAMS1H)",RMA,$realtime);
    end // if of MES_ALL="ON" && $realtime != 0
  end // if of RMA != 4'b0010
 end
  if (is_rm_Valid(RMA) != `True)
  begin
    flaga_rm_ok = `False;
  end // if of is_rm_Valid(RMA) is not true
  if (flaga_adr_ok && flaga_read_ok && flaga_rm_ok)
  begin : OUTPUT_a
    if (WEAlatched === 1'b0)
    begin
      if (ADRAlatched <= 7'b1111111)
      begin
          QA_local_tmp = mem_core_array[ADRAlatched]^mem_fault_array_XOR[ADRAlatched];
      end // if of ADRAlatched <= 7'b1111111
    end // if of WEAlatched = 0
  end //if of flaga_adr_ok is true and flaga_read_ok is true and flaga_rm_ok is true
  else
  begin
    if (flaga_viol)
    begin
      if ((WEAlatched === 1'b0))
      begin
        QA_local_tmp = 32'bx;
        flaga_read_ok = `True;
      end  // if of read
    end // if of flaga_viol is true
    else
    begin
      QA_local_tmp = 32'bx;
      flaga_read_ok = `True;
    end // else of if flaga_viol is true
  end // else of if flaga_adr_ok is true and flaga_read_ok is true and flaga_rm_ok is true
end // end of always block blk_readout_0

// Handle Read/Write
always @(ev_RST_out_a_port)
begin : blk_readwrite_0
    if (MEAlatched !== 1'b0 && !flaga_viol)
    begin
      if (WEAlatched === 1'bx)
      begin
        flaga_we_ok = `False;
        flaga_read_ok = `False;
        report_unknown("WEA");
      end // if of WEAlatched = X
      if ((^DAlatched === 1'bx))
      begin
        if (DAlatched === 32'bx)
        begin
          flaga_d_ok  = `False;
        end
        if (WEAlatched !== 1'b0)
        begin
          report_unknown("DA");
        end
      end
          if (TEST1Alatched === 1'bx)
          begin
            report_unknown("TEST1A");
            if ( WEAlatched == 1'b1 )
            begin
              corrupt_cur_loc(ADRAlatched);                             
            end // if of WEAlatched = 1
            else
            begin
              QA_local_tmp = 32'bx;
            end // else of if WEAlatched = 1
          end // if TEST1Alatched = X
          else
          begin
                if (^RMA === 1'bx)
                begin
                  report_unknown("RMA");
                  if ( WEAlatched == 1'b1 )
                  begin
                    corrupt_cur_loc(ADRAlatched);
                  end // if of WEAlatched = 1
                  else
                  begin
                    QA_local_tmp = 32'bx;
                  end // else of if WEAlatched = 1
                end // if of RMA = X
                else
                begin
                  if (MEAlatched !== 1'b1)
                  begin
                    flaga_we_ok = `False;       // don't know if cycle is On or Off
                  end // if of MEAlatched != 1 

                  if(ADRAlatched > 7'b1111111) 
                  begin
                    $display("\n%m VIRL_MEM_WARNING:address is out of range\n RANGE:0 to 127\n");
                    flaga_range_ok = `False;
                    if (WEAlatched === 1'b0)
                    begin
                      flaga_read_ok = `False;
                    end // if of flaga_read_ok
                  end // if of ADRAlatched out of range with MEAlatched = 1
                  if ( MEAlatched === 1'bx )
                  begin
                    report_unknown("MEA");
                    `ifdef virage_ignore_read_addx
                    if (WEAlatched == 1'b1)
                    begin
                      corrupt_all_loc(flaga_range_ok);
                    end // if of WEAlatched = 1 
                    else
                    begin
                      QA_local_tmp = 32'bx;
                    end // else of if WEAlatched = 1
                    `else
                    if (WEAlatched == 1'b1)
                    begin
                      corrupt_all_loc(flaga_range_ok);
                    end // if of WEAlatched = 1
                    else
                    begin
                      QA_local_tmp = 32'bx;
                      corrupt_all_loc(flaga_range_ok);
                    end // else of if WEAlatched = 1
                    `endif
                  end // if of MEAlatched = X
                  else
                  begin
                      if (flaga_range_ok && flaga_we_ok && flaga_adr_ok && flaga_d_ok && (WEAlatched == 1'b1))
                      begin
                        mem_core_array[ADRAlatched] = DAlatched;
                          if (!mes_all_valid)
                          begin
                            mes_all_valid = 1'b1;
                          end // if of mes_all_valid = 0
                      end // if of write
                      else
                      begin
                        checkSanityOnAport;
                      end // else of if write
                  if (TEST1Alatched === 1'b1)
                  begin
                     if (WEAlatched === 1'b0)
                     begin
                       flaga_read_ok = `False;
                       -> ev_read_out_a_port;
                       @(negedge CLKA);
                     end
                     -> ev_read_out_a_port;
                  end // if of TEST1Alatched = 1
                  else 
                  begin
                    -> ev_read_out_a_port;
                  end // else of if TEST1Alatched = 1
                  end // else of if MEAlatched = X
                end // else of if RMA = X
          end // else of if TEST1Alatched = X
    end // if of MEAlatched != 0 & flaga_viol = 0
end // end of always block blk_readwrite_0



assign QA_temp = QA_local_tmp;

// Final Output Update 

always @( QA_temp )
begin : blk_output_0
    `ifdef VIRAGE_FAST_VERILOG
    #(O_delay) QA <= QA_temp;
    `else
    QA <= 32'bx;
    #0.001;
    QA <= QA_temp;
    `endif // endif of VIRAGE_FAST_VERILOG
end // end of always block blk_output_0


// Display the warning when TEST1A is 1.
always @ (TEST1A)
begin : blk_test1_0
  if ( TEST1A == 1'b1)
  begin
    if( MES_ALL=="ON" && $realtime != 0 && mes_all_valid)
    begin
      $display("\n%m VERILOG> VIRL_MEM_WARNING: Tcc value in the RAM model is for TEST1A=1'b0,but input value is TEST1A=1'b1 (time %0t)\n\n", $time);
    end
  end // if TEST1A = 1 
end // end of always block blk_test1_0

`ifdef VIRAGE_FAST_VERILOG
`else
// PORT B WE violation
always @(notif_web)           
begin : blk_notif_we_1
    if ( WEB_old === 1'b0)
    begin
      flagb_viol = `True;
    end // if of WEB_old = 0
    flagb_we_ok = `False;
    checkSanityOnBport;
    flagb_read_ok = `False;
    -> ev_read_out_b_port;
end // end of always block blk_notif_we_1

// PORT B CLK violation
always @(notif_clkb)
begin : blk_notif_clk_1
  flagb_clk_valid = `False;
  MEA_chk = MEA_old;
  if ( EVENT_TCQ_A == 1'b1 && MEA_chk === 1'b1 )
  begin
    disable blk_readout_0.OUTPUT_a;
    flaga_read_ok = `False;
    -> ev_read_out_a_port;
  end 
  flagb_adr_ok = `False;
  flagb_we_ok  = `False;
  checkSanityOnBport;
  flagb_read_ok = `False;     // irrespective of WE
  -> ev_read_out_b_port;
end // end of always block blk_notif_clk_1

// PORT B ME violation
always @(notif_meb)           
begin : blk_notif_me_1
  if (((WEBlatched === 1'b1)) && (EVENT_TCQ_A == 1'b1 || (tcqa_time == $realtime)))
  begin
    disable blk_readout_0.OUTPUT_a;
    flaga_read_ok = `False;
    -> ev_read_out_a_port;
  end // if of write
    flagb_viol = `True;
    flagb_read_ok = `False;                           
    -> ev_read_out_b_port;
    flagb_adr_ok = `False;
    checkSanityOnBport;
end // end of always block blk_notif_me_1

// PORT B ADR violation
always @(notif_adrb)     
begin : blk_notif_addr_1
   MEA_chk = MEA_old;
   if (MEA_chk === 1'b1 && ((WEBlatched === 1'b1)) && (EVENT_TCQ_A == 1'b1 || (tcqa_time == $realtime)))
    begin
      disable blk_readout_0.OUTPUT_a;
      flaga_read_ok = `False;
      -> ev_read_out_a_port;
    end // if of write
      flagb_viol = `True;
      flagb_read_ok = `False;                         
      -> ev_read_out_b_port;
      flagb_adr_ok = `False;
      corrupt_all_loc(`True);
end // end of always block blk_notif_addr_1

// PORT B D violation
always @(notif_db)     
begin : blk_notif_di_1
    flagb_viol = `True;
    flagb_read_ok = `False;
    -> ev_read_out_b_port;
    flagb_d_ok = `False;
    checkSanityOnBport;
end // end of always block blk_notif_di_1

//PORT B TEST1 violation
always @(notif_test1b)   
begin : blk_notif_test1_1
//  MEB_chk = MEB_old;
    flagb_viol = `True;
    flagb_read_ok = `False;
    -> ev_read_out_b_port;
    flagb_d_ok  = `False;
    checkSanityOnBport;
end // end of always block blk_notif_test1_1

//PORT B RM violation
always @(notif_rmb)       
begin : blk_notif_rm_1
    flagb_viol = `True;
    flagb_read_ok = `False;
    -> ev_read_out_b_port;
    flagb_d_ok  = `False;
    checkSanityOnBport;
end // end of always block blk_notif_rm_1

//PORT B RME violation
always @(notif_rmeb)  
begin : blk_notif_rmen_1
    flagb_viol = `True;
    flagb_read_ok = `False;
    -> ev_read_out_b_port;
    flagb_d_ok  = `False;
    checkSanityOnBport;
end // end of always block blk_notif_rmen_1


`endif // endif of VIRAGE_FAST_VERILOG

// Simultaneous Clock Handling
`ifdef VIRAGE_FAST_VERILOG
always @(sim_check_B)
begin : blk_simultclock_1
`else
always @(notif_clkb_CLKA_rise_rise_rec)
begin : blk_simultclock_1
`endif // endif of VIRAGE_FAST_VERILOG
      if ( WEBlatched !== 1'b0 && WEA_old  !== 1'b0 )
      begin
        flaga_d_ok = `False;
        flagb_d_ok = `False;
        checkSanityOnAport;           // corrupt current location
      end // if write enable is not disabled for both ports
      else if ( WEBlatched !== 1'b0)
      begin
        #0;
        flaga_viol = `True;
        flaga_read_ok = `False;
        -> ev_read_out_a_port;
      end // else if of WEBlatched != 0
      else 
      begin
        flagb_read_ok = `False;
        -> ev_read_out_b_port;
      end // else if of WEA_old  != 0
end // end of always block blk_simultclock_1

`ifdef VIRAGE_FAST_VERILOG
`else
`endif // endif of VIRAGE_FAST_VERILOG

// reset for next cycle

always @(negedge CLKB)
begin : blk_intnegclock_1
  if (flagb_clk_valid)
  begin
    flagb_adr_ok  = `True;
    flagb_we_ok   = `True;
    flagb_d_ok    = `True;
    flagb_viol    = `False;
  end // if of flagb_clk_valid is true
  if ( CLKB !== 1'bx )
  begin
    #0.001;
    flagb_range_ok  = `True;
    flagb_read_ok = `True;
    flagb_rm_ok = `True;
    flagb_clk_valid = `True;
  end // if of CLKB != X
  else
  begin
    flagb_clk_valid = `False;
    QB_local_tmp = 32'bx;
    corrupt_all_loc(`True);
    report_unknown("CLKB");
  end // else of if CLKB != X
end // end of always block blk_intnegclock_1

// PORT B FUNCTIONALITY 


always @(posedge CLKB)
begin : blk_intposclock_1
  CLKB_T = $realtime;
  MEBlatched = MEB_old;
  WEBlatched = WEB_old;
  TEST1Blatched = TEST1B_old;
  ADRBlatched = ADRB_old;
  DBlatched = DB_old;
  if (is_x(ADRBlatched) == `True && MEBlatched !== 1'b0)
  begin
    report_unknown("ADRB");
    if ( WEBlatched === 1'b1 )
    begin
      flagb_viol = `True;
    end // if of WEBlatched = 1
    else
    begin
      flagb_read_ok = `False;
    end
    `ifdef virage_ignore_read_addx
    if ((WEBlatched === 1'b1))
    begin
      flagb_adr_ok = `False;
      corrupt_all_loc(flagb_range_ok);
    end // if of write
    `else
    flagb_adr_ok = `False;
    corrupt_all_loc(flagb_range_ok);
    `endif // endif of virage_ignore_read_addx is true
    -> ev_RST_out_b_port;
  end // if of is_x(ADRBlatched) is true and MEBlatched != 0
  else if((ADRBlatched > 7'b1111111) && (MEBlatched === 1'b1) && (WEBlatched === 1'b1) )
  begin
    $display("\n%m VIRL_MEM_WARNING:address is out of range\n RANGE: 0 to 127\n");
    flagb_range_ok = `False;
  end // if of ADRBlatched out of range with MEBlatched = 1
  else
  begin
  end // else of if is_x(ADRBlatched) is true and MEBlatched != 0
  if (!flagb_clk_valid) 
  begin
    QB_local_tmp = 32'bx;
  end // if of flagb_clk_valid is NOT true
  else if ( CLKB === 1'bx )
  begin
    QB_local_tmp = 32'bx;
    corrupt_all_loc(flagb_range_ok);
    report_unknown("CLKB");
  end // if of CLKB = X
  else
  begin
      -> ev_RST_out_b_port;
  end // else of if CLKB = X
end // end of always block blk_intposclock_1
// PORT B READ-OUT

always @(ev_read_out_b_port)
begin : blk_readout_1
  #0                // let CLOCK and NOTIFIER module execute first
  if (RMEB === 1'b1)
  begin
    if (RMB >= 4'b0100)
    begin
      if( MES_ALL=="ON" && $realtime != 0)
      begin
      $display("RMB = %b is not recommended value at time=%t; instance=%m (RAMS1H)",RMB,$realtime);
      end
    end
  end
  else
  begin
  if (RMB != 4'b0010)
  begin
    if( MES_ALL=="ON" && $realtime != 0)
    begin
      $display("RMB = %b is not recommended value at time=%t; instance=%m (RAMS1H)",RMB,$realtime);
    end // if of MES_ALL="ON" && $realtime != 0
  end // if of RMB != 4'b0010
 end
  if (is_rm_Valid(RMB) != `True)
  begin
    flagb_rm_ok = `False;
  end // if of is_rm_Valid(RMB) is not true
  if (flagb_adr_ok && flagb_read_ok && flagb_rm_ok)
  begin : OUTPUT_b
    if (WEBlatched === 1'b0)
    begin
      if (ADRBlatched <= 7'b1111111)
      begin
          QB_local_tmp = mem_core_array[ADRBlatched]^mem_fault_array_XOR[ADRBlatched];
      end // if of ADRBlatched <= 7'b1111111
    end // if of WEBlatched = 0
  end //if of flagb_adr_ok is true and flagb_read_ok is true and flagb_rm_ok is true
  else
  begin
    if (flagb_viol)
    begin
      if ((WEBlatched === 1'b0))
      begin
        QB_local_tmp = 32'bx;
        flagb_read_ok = `True;
      end  // if of read
    end // if of flagb_viol is true
    else
    begin
      QB_local_tmp = 32'bx;
      flagb_read_ok = `True;
    end // else of if flagb_viol is true
  end // else of if flagb_adr_ok is true and flagb_read_ok is true and flagb_rm_ok is true
end // end of always block blk_readout_1

// Handle Read/Write
always @(ev_RST_out_b_port)
begin : blk_readwrite_1
    if (MEBlatched !== 1'b0 && !flagb_viol)
    begin
      if (WEBlatched === 1'bx)
      begin
        flagb_we_ok = `False;
        flagb_read_ok = `False;
        report_unknown("WEB");
      end // if of WEBlatched = X
      if ((^DBlatched === 1'bx))
      begin
        if (DBlatched === 32'bx)
        begin
          flagb_d_ok  = `False;
        end
        if (WEBlatched !== 1'b0)
        begin
          report_unknown("DB");
        end
      end
          if (TEST1Blatched === 1'bx)
          begin
            report_unknown("TEST1B");
            if ( WEBlatched == 1'b1 )
            begin
              corrupt_cur_loc(ADRBlatched);                             
            end // if of WEBlatched = 1
            else
            begin
              QB_local_tmp = 32'bx;
            end // else of if WEBlatched = 1
          end // if TEST1Blatched = X
          else
          begin
                if (^RMB === 1'bx)
                begin
                  report_unknown("RMB");
                  if ( WEBlatched == 1'b1 )
                  begin
                    corrupt_cur_loc(ADRBlatched);
                  end // if of WEBlatched = 1
                  else
                  begin
                    QB_local_tmp = 32'bx;
                  end // else of if WEBlatched = 1
                end // if of RMB = X
                else
                begin
                  if (MEBlatched !== 1'b1)
                  begin
                    flagb_we_ok = `False;       // don't know if cycle is On or Off
                  end // if of MEBlatched != 1 

                  if(ADRBlatched > 7'b1111111) 
                  begin
                    $display("\n%m VIRL_MEM_WARNING:address is out of range\n RANGE:0 to 127\n");
                    flagb_range_ok = `False;
                    if (WEBlatched === 1'b0)
                    begin
                      flagb_read_ok = `False;
                    end // if of flagb_read_ok
                  end // if of ADRBlatched out of range with MEBlatched = 1
                  if ( MEBlatched === 1'bx )
                  begin
                    report_unknown("MEB");
                    `ifdef virage_ignore_read_addx
                    if (WEBlatched == 1'b1)
                    begin
                      corrupt_all_loc(flagb_range_ok);
                    end // if of WEBlatched = 1 
                    else
                    begin
                      QB_local_tmp = 32'bx;
                    end // else of if WEBlatched = 1
                    `else
                    if (WEBlatched == 1'b1)
                    begin
                      corrupt_all_loc(flagb_range_ok);
                    end // if of WEBlatched = 1
                    else
                    begin
                      QB_local_tmp = 32'bx;
                      corrupt_all_loc(flagb_range_ok);
                    end // else of if WEBlatched = 1
                    `endif
                  end // if of MEBlatched = X
                  else
                  begin
                      if (flagb_range_ok && flagb_we_ok && flagb_adr_ok && flagb_d_ok && (WEBlatched == 1'b1))
                      begin
                        mem_core_array[ADRBlatched] = DBlatched;
                          if (!mes_all_valid)
                          begin
                            mes_all_valid = 1'b1;
                          end // if of mes_all_valid = 0
                      end // if of write
                      else
                      begin
                        checkSanityOnBport;
                      end // else of if write
                  if (TEST1Blatched === 1'b1)
                  begin
                     if (WEBlatched === 1'b0)
                     begin
                       flagb_read_ok = `False;
                       -> ev_read_out_b_port;
                       @(negedge CLKB);
                     end
                     -> ev_read_out_b_port;
                  end // if of TEST1Blatched = 1
                  else 
                  begin
                    -> ev_read_out_b_port;
                  end // else of if TEST1Blatched = 1
                  end // else of if MEBlatched = X
                end // else of if RMB = X
          end // else of if TEST1Blatched = X
    end // if of MEBlatched != 0 & flagb_viol = 0
end // end of always block blk_readwrite_1



assign QB_temp = QB_local_tmp;

// Final Output Update 

always @( QB_temp )
begin : blk_output_1
    `ifdef VIRAGE_FAST_VERILOG
    #(O_delay) QB <= QB_temp;
    `else
    QB <= 32'bx;
    #0.001;
    QB <= QB_temp;
    `endif // endif of VIRAGE_FAST_VERILOG
end // end of always block blk_output_1


// Display the warning when TEST1B is 1.
always @ (TEST1B)
begin : blk_test1_1
  if ( TEST1B == 1'b1)
  begin
    if( MES_ALL=="ON" && $realtime != 0 && mes_all_valid)
    begin
      $display("\n%m VERILOG> VIRL_MEM_WARNING: Tcc value in the RAM model is for TEST1B=1'b0,but input value is TEST1B=1'b1 (time %0t)\n\n", $time);
    end
  end // if TEST1B = 1 
end // end of always block blk_test1_1

endmodule

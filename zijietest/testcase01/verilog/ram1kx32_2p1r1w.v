//==================================================================================//
// Author: GWX Technology
// Attribution: Verilog-HDL
// Birthday: Tue Oct 10 15:44:31 CST 2023
// Organization: GWX Technology
// Copyright: GWX Technology Â©2023 GWX Technology Inc. All rights reserved.
//----------------------------------------------------------------------------------//
// Description:
// All the data in the file was generated by GWX Technology. This information was
// prepared only for EDA tools training. GWX Technology does not guarantee the
// accuracy or completeness of the information contained herein. GWX Technology
// shall not be liable for any loss or damage of any kind arising from the use of
// this document or the information contained herein.
//----------------------------------------------------------------------------------//
// Version: 0.9.0.0 Alpha
//==================================================================================//

//   --------------------------------------------------------------     
//                       Template Revision : 3.7.8                      
//   --------------------------------------------------------------     
//                      * Synchronous, 2-Port SRAM *                  
//                      * Verilog Behavioral Model *                  
//                THIS IS A SYNCHRONOUS 2-PORT MEMORY MODEL           
//                                                                    
//   Memory Name:ram1kx32_2p1r1w                                      
//   Memory Size:1024 words x 32 bits                                 
//                                                                    
//                               PORT NAME                            
//                               ---------                            
//               Output Ports                                         
//                                   QB[31:0]                         
//               Input Ports:                                         
//                                   ADRA[9:0]                        
//                                   DA[31:0]                         
//                                   WEA                              
//                                   MEA                              
//                                   CLKA                             
//                                   TEST1A                           
//                                   WMENA                            
//                                   ADRB[9:0]                        
//                                   MEB                              
//                                   CLKB                             
//                                   TEST1B                           
//                                   RMB[3:0]                         
//                                   RMEB                             

`resetall 
`timescale 1 ns / 1 ps 
`celldefine 
`ifdef verifault // for fault simulation purpose 
`suppress_faults 
`enable_portfaults 
`endif 

`define True    1'b1
`define False   1'b0




module ram1kx32_2p1r1w ( QB, ADRA, DA, WEA, MEA, CLKA, TEST1A, WMENA, ADRB, MEB, CLKB, TEST1B, RMB, RMEB);

output  [31:0] QB;
input  [9:0] ADRA;
input  [31:0] DA;
input WEA;
input MEA;
input CLKA;
input TEST1A;
input WMENA;
input  [9:0] ADRB;
input MEB;
input CLKB;
input TEST1B;
input  [3:0] RMB;
input RMEB;


// Local registers, wires, etc

`ifdef MEM_CHECK_OFF
parameter MES_ALL = "OFF";
`else
parameter MES_ALL = "ON";
`endif // MEM_CHECK_OFF

`ifdef VIRAGE_IGNORE_SAME_ADDR_MSG
parameter debug_mode = 0;
`else
parameter debug_mode = 1;
`endif // VIRAGE_IGNORE_SAME_ADDR_MSG


`ifdef VIRAGE_FAST_VERILOG
`else
reg notif_adra;
reg notif_da;
reg notif_wea;
reg notif_mea;
reg notif_clka;
reg notif_clka_CLKB_rise_rise_rec;
reg notif_test1a;
reg notif_wmena;
reg notif_adrb;
reg notif_meb;
reg notif_clkb;
reg notif_clkb_CLKA_rise_rise_rec;
reg notif_test1b;
reg notif_rmb;
reg notif_rmb_a;
reg notif_rmeb;
`endif // VIRAGE_FAST_VERILOG

reg  [9 : 0 ] ADRA_buf_L;
reg  [9 : 0 ] ADRA_pre;
reg  MEA_pre;
reg  WEA_pre;
reg  CLKB_tcq;
reg  [9 : 0 ] ADRB_buf_L;
reg  [9 : 0 ] ADRB_pre;
reg  MEB_pre;




wire [31:0] QB_final;

`ifdef VIRAGE_FAST_VERILOG
wire [31:0] QB_buf;
assign QB[0] = QB_buf[0];
assign QB[1] = QB_buf[1];
assign QB[2] = QB_buf[2];
assign QB[3] = QB_buf[3];
assign QB[4] = QB_buf[4];
assign QB[5] = QB_buf[5];
assign QB[6] = QB_buf[6];
assign QB[7] = QB_buf[7];
assign QB[8] = QB_buf[8];
assign QB[9] = QB_buf[9];
assign QB[10] = QB_buf[10];
assign QB[11] = QB_buf[11];
assign QB[12] = QB_buf[12];
assign QB[13] = QB_buf[13];
assign QB[14] = QB_buf[14];
assign QB[15] = QB_buf[15];
assign QB[16] = QB_buf[16];
assign QB[17] = QB_buf[17];
assign QB[18] = QB_buf[18];
assign QB[19] = QB_buf[19];
assign QB[20] = QB_buf[20];
assign QB[21] = QB_buf[21];
assign QB[22] = QB_buf[22];
assign QB[23] = QB_buf[23];
assign QB[24] = QB_buf[24];
assign QB[25] = QB_buf[25];
assign QB[26] = QB_buf[26];
assign QB[27] = QB_buf[27];
assign QB[28] = QB_buf[28];
assign QB[29] = QB_buf[29];
assign QB[30] = QB_buf[30];
assign QB[31] = QB_buf[31];
wire [9:0] ADRA_buf;
assign  ADRA_buf[0] =  ADRA[0];
assign  ADRA_buf[1] =  ADRA[1];
assign  ADRA_buf[2] =  ADRA[2];
assign  ADRA_buf[3] =  ADRA[3];
assign  ADRA_buf[4] =  ADRA[4];
assign  ADRA_buf[5] =  ADRA[5];
assign  ADRA_buf[6] =  ADRA[6];
assign  ADRA_buf[7] =  ADRA[7];
assign  ADRA_buf[8] =  ADRA[8];
assign  ADRA_buf[9] =  ADRA[9];
wire [31:0] DA_buf;
assign  DA_buf[0] =  DA[0];
assign  DA_buf[1] =  DA[1];
assign  DA_buf[2] =  DA[2];
assign  DA_buf[3] =  DA[3];
assign  DA_buf[4] =  DA[4];
assign  DA_buf[5] =  DA[5];
assign  DA_buf[6] =  DA[6];
assign  DA_buf[7] =  DA[7];
assign  DA_buf[8] =  DA[8];
assign  DA_buf[9] =  DA[9];
assign  DA_buf[10] =  DA[10];
assign  DA_buf[11] =  DA[11];
assign  DA_buf[12] =  DA[12];
assign  DA_buf[13] =  DA[13];
assign  DA_buf[14] =  DA[14];
assign  DA_buf[15] =  DA[15];
assign  DA_buf[16] =  DA[16];
assign  DA_buf[17] =  DA[17];
assign  DA_buf[18] =  DA[18];
assign  DA_buf[19] =  DA[19];
assign  DA_buf[20] =  DA[20];
assign  DA_buf[21] =  DA[21];
assign  DA_buf[22] =  DA[22];
assign  DA_buf[23] =  DA[23];
assign  DA_buf[24] =  DA[24];
assign  DA_buf[25] =  DA[25];
assign  DA_buf[26] =  DA[26];
assign  DA_buf[27] =  DA[27];
assign  DA_buf[28] =  DA[28];
assign  DA_buf[29] =  DA[29];
assign  DA_buf[30] =  DA[30];
assign  DA_buf[31] =  DA[31];
wire WEA_buf;
assign  WEA_buf =  WEA;
wire MEA_buf;
assign  MEA_buf =  MEA;
wire CLKA_buf;
assign  CLKA_buf =  CLKA;
wire TEST1A_buf;
assign  TEST1A_buf =  TEST1A;
wire WMENA_buf;
assign  WMENA_buf =  WMENA;
wire [9:0] ADRB_buf;
assign  ADRB_buf[0] =  ADRB[0];
assign  ADRB_buf[1] =  ADRB[1];
assign  ADRB_buf[2] =  ADRB[2];
assign  ADRB_buf[3] =  ADRB[3];
assign  ADRB_buf[4] =  ADRB[4];
assign  ADRB_buf[5] =  ADRB[5];
assign  ADRB_buf[6] =  ADRB[6];
assign  ADRB_buf[7] =  ADRB[7];
assign  ADRB_buf[8] =  ADRB[8];
assign  ADRB_buf[9] =  ADRB[9];
wire MEB_buf;
assign  MEB_buf =  MEB;
wire CLKB_buf;
assign  CLKB_buf =  CLKB;
wire TEST1B_buf;
assign  TEST1B_buf =  TEST1B;
wire [3:0] RMB_buf;
assign  RMB_buf[0] =  RMB[0];
assign  RMB_buf[1] =  RMB[1];
assign  RMB_buf[2] =  RMB[2];
assign  RMB_buf[3] =  RMB[3];
wire RMEB_buf;
assign  RMEB_buf =  RMEB;
`else
wire [31:0] QB_buf;
buf (QB[0], QB_buf[0]);
buf (QB_final[0],QB[0]);
buf (QB[1], QB_buf[1]);
buf (QB_final[1],QB[1]);
buf (QB[2], QB_buf[2]);
buf (QB_final[2],QB[2]);
buf (QB[3], QB_buf[3]);
buf (QB_final[3],QB[3]);
buf (QB[4], QB_buf[4]);
buf (QB_final[4],QB[4]);
buf (QB[5], QB_buf[5]);
buf (QB_final[5],QB[5]);
buf (QB[6], QB_buf[6]);
buf (QB_final[6],QB[6]);
buf (QB[7], QB_buf[7]);
buf (QB_final[7],QB[7]);
buf (QB[8], QB_buf[8]);
buf (QB_final[8],QB[8]);
buf (QB[9], QB_buf[9]);
buf (QB_final[9],QB[9]);
buf (QB[10], QB_buf[10]);
buf (QB_final[10],QB[10]);
buf (QB[11], QB_buf[11]);
buf (QB_final[11],QB[11]);
buf (QB[12], QB_buf[12]);
buf (QB_final[12],QB[12]);
buf (QB[13], QB_buf[13]);
buf (QB_final[13],QB[13]);
buf (QB[14], QB_buf[14]);
buf (QB_final[14],QB[14]);
buf (QB[15], QB_buf[15]);
buf (QB_final[15],QB[15]);
buf (QB[16], QB_buf[16]);
buf (QB_final[16],QB[16]);
buf (QB[17], QB_buf[17]);
buf (QB_final[17],QB[17]);
buf (QB[18], QB_buf[18]);
buf (QB_final[18],QB[18]);
buf (QB[19], QB_buf[19]);
buf (QB_final[19],QB[19]);
buf (QB[20], QB_buf[20]);
buf (QB_final[20],QB[20]);
buf (QB[21], QB_buf[21]);
buf (QB_final[21],QB[21]);
buf (QB[22], QB_buf[22]);
buf (QB_final[22],QB[22]);
buf (QB[23], QB_buf[23]);
buf (QB_final[23],QB[23]);
buf (QB[24], QB_buf[24]);
buf (QB_final[24],QB[24]);
buf (QB[25], QB_buf[25]);
buf (QB_final[25],QB[25]);
buf (QB[26], QB_buf[26]);
buf (QB_final[26],QB[26]);
buf (QB[27], QB_buf[27]);
buf (QB_final[27],QB[27]);
buf (QB[28], QB_buf[28]);
buf (QB_final[28],QB[28]);
buf (QB[29], QB_buf[29]);
buf (QB_final[29],QB[29]);
buf (QB[30], QB_buf[30]);
buf (QB_final[30],QB[30]);
buf (QB[31], QB_buf[31]);
buf (QB_final[31],QB[31]);
wire [9:0] ADRA_buf;
buf (ADRA_buf[0], ADRA[0]);
buf (ADRA_buf[1], ADRA[1]);
buf (ADRA_buf[2], ADRA[2]);
buf (ADRA_buf[3], ADRA[3]);
buf (ADRA_buf[4], ADRA[4]);
buf (ADRA_buf[5], ADRA[5]);
buf (ADRA_buf[6], ADRA[6]);
buf (ADRA_buf[7], ADRA[7]);
buf (ADRA_buf[8], ADRA[8]);
buf (ADRA_buf[9], ADRA[9]);
wire [31:0] DA_buf;
buf (DA_buf[0], DA[0]);
buf (DA_buf[1], DA[1]);
buf (DA_buf[2], DA[2]);
buf (DA_buf[3], DA[3]);
buf (DA_buf[4], DA[4]);
buf (DA_buf[5], DA[5]);
buf (DA_buf[6], DA[6]);
buf (DA_buf[7], DA[7]);
buf (DA_buf[8], DA[8]);
buf (DA_buf[9], DA[9]);
buf (DA_buf[10], DA[10]);
buf (DA_buf[11], DA[11]);
buf (DA_buf[12], DA[12]);
buf (DA_buf[13], DA[13]);
buf (DA_buf[14], DA[14]);
buf (DA_buf[15], DA[15]);
buf (DA_buf[16], DA[16]);
buf (DA_buf[17], DA[17]);
buf (DA_buf[18], DA[18]);
buf (DA_buf[19], DA[19]);
buf (DA_buf[20], DA[20]);
buf (DA_buf[21], DA[21]);
buf (DA_buf[22], DA[22]);
buf (DA_buf[23], DA[23]);
buf (DA_buf[24], DA[24]);
buf (DA_buf[25], DA[25]);
buf (DA_buf[26], DA[26]);
buf (DA_buf[27], DA[27]);
buf (DA_buf[28], DA[28]);
buf (DA_buf[29], DA[29]);
buf (DA_buf[30], DA[30]);
buf (DA_buf[31], DA[31]);
buf (WEA_buf, WEA);
buf (MEA_buf, MEA);
buf (CLKA_buf, CLKA);
buf (TEST1A_buf, TEST1A);
buf (WMENA_buf, WMENA);
wire [9:0] ADRB_buf;
buf (ADRB_buf[0], ADRB[0]);
buf (ADRB_buf[1], ADRB[1]);
buf (ADRB_buf[2], ADRB[2]);
buf (ADRB_buf[3], ADRB[3]);
buf (ADRB_buf[4], ADRB[4]);
buf (ADRB_buf[5], ADRB[5]);
buf (ADRB_buf[6], ADRB[6]);
buf (ADRB_buf[7], ADRB[7]);
buf (ADRB_buf[8], ADRB[8]);
buf (ADRB_buf[9], ADRB[9]);
buf (MEB_buf, MEB);
buf (CLKB_buf, CLKB);
buf (TEST1B_buf, TEST1B);
wire [3:0] RMB_buf;
buf (RMB_buf[0], RMB[0]);
buf (RMB_buf[1], RMB[1]);
buf (RMB_buf[2], RMB[2]);
buf (RMB_buf[3], RMB[3]);
buf (RMEB_buf, RMEB);
`endif // VIRAGE_FAST_VERILOG

`ifdef VIRAGE_FAST_VERILOG
`else
// Setup/hold condition for CLK: ENCLK
reg  ENCLK_PA_reg,ENCLKI_PA;
wire ENCLKA;

always @( MEA_buf )
begin
  ENCLK_PA_reg = 1'b1; 
  if ( ENCLKI_PA == 1'b1 )
     ENCLKI_PA = 1'b0; 
end

always @(posedge CLKA_buf)
begin
  #0.001; 
  if (MEA_buf === 1'b0)
  begin
    if (ENCLKI_PA == 1'b1)
      ENCLK_PA_reg = 1'b0; 
    else    
      ENCLKI_PA = 1'b1; 
  end
end

assign ENCLKA = ENCLK_PA_reg ;
wire ENCLKA_rmezo,ENCLKA_vdm,ENCLKA_slw,ENCLKA_def,ENCLKA_fst;
assign ENCLKA_rmezo = ENCLK_PA_reg && RMEB_buf !== 1'b1 ;
assign ENCLKA_vdm = ENCLK_PA_reg && RMEB_buf === 1'b1  && ( (!RMB_buf[0]) && (!RMB_buf[1]) && (!RMB_buf[2]) && (!RMB_buf[3]) ) ;
assign ENCLKA_slw = ENCLK_PA_reg && RMEB_buf === 1'b1  && ( (RMB_buf[0]) && (!RMB_buf[1]) && (!RMB_buf[2]) && (!RMB_buf[3]) ) ;
assign ENCLKA_def = ENCLK_PA_reg && RMEB_buf === 1'b1  && ( (!RMB_buf[0]) && (RMB_buf[1]) && (!RMB_buf[2]) && (!RMB_buf[3]) ) ;
assign ENCLKA_fst = ENCLK_PA_reg && RMEB_buf === 1'b1  && ( (RMB_buf[0]) && (RMB_buf[1]) && (!RMB_buf[2]) && (!RMB_buf[3]) ) ;
// Setup/hold condition for CLK: ENCLK
reg  ENCLK_PB_reg,ENCLKI_PB;
wire ENCLKB;

always @( MEB_buf )
begin
  ENCLK_PB_reg = 1'b1; 
  if ( ENCLKI_PB == 1'b1 )
     ENCLKI_PB = 1'b0; 
end

always @(posedge CLKB_buf)
begin
  #0.001; 
  if (MEB_buf === 1'b0)
  begin
    if (ENCLKI_PB == 1'b1)
      ENCLK_PB_reg = 1'b0; 
    else    
      ENCLKI_PB = 1'b1; 
  end
end

assign ENCLKB = ENCLK_PB_reg ;
wire ENCLKB_rmezo,ENCLKB_vdm,ENCLKB_slw,ENCLKB_def,ENCLKB_fst;
assign ENCLKB_rmezo = ENCLK_PB_reg && RMEB_buf !== 1'b1 ;
assign ENCLKB_vdm = ENCLK_PB_reg && RMEB_buf === 1'b1  && ( (!RMB_buf[0]) && (!RMB_buf[1]) && (!RMB_buf[2]) && (!RMB_buf[3]) ) ;
assign ENCLKB_slw = ENCLK_PB_reg && RMEB_buf === 1'b1  && ( (RMB_buf[0]) && (!RMB_buf[1]) && (!RMB_buf[2]) && (!RMB_buf[3]) ) ;
assign ENCLKB_def = ENCLK_PB_reg && RMEB_buf === 1'b1  && ( (!RMB_buf[0]) && (RMB_buf[1]) && (!RMB_buf[2]) && (!RMB_buf[3]) ) ;
assign ENCLKB_fst = ENCLK_PB_reg && RMEB_buf === 1'b1  && ( (RMB_buf[0]) && (RMB_buf[1]) && (!RMB_buf[2]) && (!RMB_buf[3]) ) ;
`endif // VIRAGE_FAST_VERILOG

`ifdef VIRAGE_FAST_VERILOG
`else
 
 
always @ (QB_final)
 begin   
  if (QB_final !== 32'bx )
       CLKB_tcq = 1'b0;
 end
always @ (negedge CLKB_buf)
 begin
   CLKB_tcq = 1'b0;
 end
wire ADRA_valid;
assign ADRA_valid = ( ( ADRA_pre < 1024 )?1'b1:1'b0);

wire ADRA_valid_rec;
assign ADRA_valid_rec = ( ( ADRA_pre < 1024  )?1'b1:1'b0);

wire ADRB_valid;
assign ADRB_valid = ( ( ADRB_pre < 1024 )?1'b1:1'b0);

wire ADRB_valid_rec;
assign ADRB_valid_rec = ( ( ADRB_pre < 1024  )?1'b1:1'b0);

`endif // VIRAGE_FAST_VERILOG

// Setup/hold conditions for syncronous signals
`ifdef VIRAGE_FAST_VERILOG
`else
// Setup/hold condition for Address: ADRA is : ENADRA
wire ENADRA;
assign ENADRA = (( MEA_pre !== 1'b0 && WEA_pre !== 1'b0 ) ?1'b1:1'b0);
 
// Setup/hold condition for Memory Enable: MEA is : ENMEA
wire ENMEA;
assign ENMEA = (( WEA_pre !== 1'b0 && ADRA_valid ) ?1'b1:1'b0);

// Setup/hold condition for Write Enable: WEA is : ENWEA
wire ENWEA;
assign ENWEA = (( ADRA_valid && MEA_pre !== 1'b0  ) ?1'b1:1'b0);

// Setup/hold condition for Data In: DA is : ENDA
wire ENDA;
assign ENDA = (( ADRA_valid && MEA_pre !== 1'b0 && WEA_pre !== 1'b0  )?1'b1:1'b0) ;
// Setup/hold condition for test1 Vector: TEST1A is : ENTEST1A
wire ENTEST1A;
assign ENTEST1A = ((MEA_pre !== 1'b0 && WEA_pre !== 1'b0 && ADRA_valid )?1'b1:1'b0);
 
// Setup/hold condition for Read Margin Vector: WMENA is : ENWMENA
wire ENWMENA;
assign ENWMENA = ((MEA_pre !== 1'b0 && WEA_pre !== 1'b0 && ADRA_valid )?1'b1:1'b0);
// Setup/hold condition for Read Margin Vector: RMA is : ENRMA
wire ENRMA;
assign ENRMA = ((MEA_pre !== 1'b0 && WEA_pre !== 1'b0 && ADRA_valid && WMENA_buf !== 1'b0 )?1'b1:1'b0);
// Setup/hold condition for Address: ADRB is : ENADRB
wire ENADRB;
buf ( ENADRB, MEB_pre );
 
// Setup/hold condition for Memory Enable: MEB is : ENMEB
wire ENMEB;
buf ( ENMEB, ADRB_valid );

// Setup/hold condition for test1 Vector: TEST1B is : ENTEST1B
wire ENTEST1B;
assign ENTEST1B = ((MEB_pre !== 1'b0 && ADRB_valid )?1'b1:1'b0);
 
// Setup/hold condition for Read Margin Vector: RMB is : ENRMB
wire ENRMB;
assign ENRMB = ((MEB_pre !== 1'b0 && ADRB_valid && RMEB_buf !== 1'b0 )?1'b1:1'b0);
// Setup/hold condition for Read Margin Vector: RMB is : ENRMEB
wire ENRMEB;
assign ENRMEB = ((MEB_pre !== 1'b0 && ADRB_valid)?1'b1:1'b0);

`endif // VIRAGE_FAST_VERILOG

reg MEA_buf_L;
reg WEA_buf_L;
reg MEB_buf_L;

`ifdef VIRAGE_FAST_VERILOG
`else

// Recovery conditions for clock signals



wire ADRA_same;

assign ADRA_same = (((ADRA_pre == ADRB_buf_L) && ADRA_valid_rec) || (CLKA_buf === 1'bx || CLKB_buf === 1'bx) || ((ADRA_pre^ADRA_pre) !== 0) || ((ADRB_buf_L^ADRB_buf_L) !== 0)) ? 1'b1:1'b0;


wire WEA_active;
assign WEA_active = ( ( WEA_pre === 1'b0 ) )?1'b0:1'b1;

wire MEA_active;
assign MEA_active = ( ( MEA_pre !== 1'b0 ) && ( MEB_buf_L !== 1'b0 ))?1'b1:1'b0;

wire   ENCLKBCLKArec;
assign ENCLKBCLKArec = ( ( ADRA_same  && MEA_active && WEA_active ) ? 1'b1:1'b0);

wire ADRB_same;

assign ADRB_same = (((ADRB_pre == ADRA_buf_L) && ADRB_valid_rec) || (CLKB_buf === 1'bx || CLKA_buf === 1'bx) || ((ADRB_pre^ADRB_pre) !== 0) || ((ADRA_buf_L^ADRA_buf_L) !== 0)) ? 1'b1:1'b0;


wire _active;
assign _active = ( ( WEA_buf_L === 1'b0 ) )?1'b0:1'b1;

wire MEB_active;
assign MEB_active = ( ( MEB_pre !== 1'b0 ) && ( MEA_buf_L !== 1'b0 ))?1'b1:1'b0;

wire   ENCLKACLKBrec;
assign ENCLKACLKBrec = ( ( ADRB_same  && MEB_active && _active ) ? 1'b1:1'b0);

wire recovery_ab;
assign recovery_ab = ( WEA_buf_L !== 1'b0 );
`endif // VIRAGE_FAST_VERILOG

`ifdef VIRAGE_FAST_VERILOG
`else
specify
 

    specparam

        Tac = 0.270,
        Tcax = 0.120,
        Tdc = 0.193,
        Tcdx = 0.248,
        Twc = 0.414,
        Tcwx = 0.000,
        Tmc = 0.592,
        Tcmx = 0.022,
        Tcsep = 0.951,
        Tcl = 0.414,
        Tch = 0.154,
        Tcc = 1.184,
        Tccvddmin = 2.251,
        Tccslow = 1.456,
        Tccdef = 1.184,
        Tccfast = 1.149,
        Tt1c = 0.039,
        Tct1x = 1.882,
        Twmec = 0.194,
        Tcwmex = 0.980,
        Trmc = 0.152,
        Tcrmx = 0.980,
        Tcq = 1.075,
        Tcqx = 0.882,
        Tcqvddmin = 2.141,
        Tcqvddminx = 1.888,
        Tcqslow = 1.442,
        Tcqslowx = 1.286,
        Tcqdef = 1.075,
        Tcqdefx = 0.948,
        Tcqfast = 1.024,
        Tcqfastx = 0.882;
     if (   !RMEB )
       ( posedge CLKB => (  QB[31]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RMEB )
       ( posedge CLKB => (  QB[30]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RMEB )
       ( posedge CLKB => (  QB[29]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RMEB )
       ( posedge CLKB => (  QB[28]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RMEB )
       ( posedge CLKB => (  QB[27]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RMEB )
       ( posedge CLKB => (  QB[26]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RMEB )
       ( posedge CLKB => (  QB[25]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RMEB )
       ( posedge CLKB => (  QB[24]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RMEB )
       ( posedge CLKB => (  QB[23]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RMEB )
       ( posedge CLKB => (  QB[22]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RMEB )
       ( posedge CLKB => (  QB[21]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RMEB )
       ( posedge CLKB => (  QB[20]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RMEB )
       ( posedge CLKB => (  QB[19]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RMEB )
       ( posedge CLKB => (  QB[18]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RMEB )
       ( posedge CLKB => (  QB[17]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RMEB )
       ( posedge CLKB => (  QB[16]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RMEB )
       ( posedge CLKB => (  QB[15]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RMEB )
       ( posedge CLKB => (  QB[14]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RMEB )
       ( posedge CLKB => (  QB[13]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RMEB )
       ( posedge CLKB => (  QB[12]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RMEB )
       ( posedge CLKB => (  QB[11]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RMEB )
       ( posedge CLKB => (  QB[10]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RMEB )
       ( posedge CLKB => (  QB[9]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RMEB )
       ( posedge CLKB => (  QB[8]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RMEB )
       ( posedge CLKB => (  QB[7]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RMEB )
       ( posedge CLKB => (  QB[6]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RMEB )
       ( posedge CLKB => (  QB[5]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RMEB )
       ( posedge CLKB => (  QB[4]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RMEB )
       ( posedge CLKB => (  QB[3]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RMEB )
       ( posedge CLKB => (  QB[2]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RMEB )
       ( posedge CLKB => (  QB[1]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RMEB )
       ( posedge CLKB => (  QB[0]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   RMEB &  !RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[31]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEB &  !RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[30]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEB &  !RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[29]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEB &  !RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[28]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEB &  !RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[27]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEB &  !RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[26]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEB &  !RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[25]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEB &  !RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[24]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEB &  !RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[23]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEB &  !RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[22]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEB &  !RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[21]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEB &  !RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[20]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEB &  !RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[19]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEB &  !RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[18]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEB &  !RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[17]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEB &  !RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[16]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEB &  !RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[15]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEB &  !RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[14]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEB &  !RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[13]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEB &  !RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[12]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEB &  !RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[11]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEB &  !RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[10]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEB &  !RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[9]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEB &  !RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[8]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEB &  !RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[7]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEB &  !RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[6]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEB &  !RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[5]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEB &  !RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[4]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEB &  !RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[3]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEB &  !RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[2]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEB &  !RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[1]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEB &  !RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[0]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RMEB &  RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[31]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEB &  RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[30]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEB &  RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[29]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEB &  RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[28]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEB &  RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[27]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEB &  RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[26]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEB &  RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[25]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEB &  RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[24]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEB &  RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[23]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEB &  RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[22]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEB &  RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[21]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEB &  RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[20]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEB &  RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[19]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEB &  RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[18]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEB &  RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[17]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEB &  RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[16]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEB &  RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[15]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEB &  RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[14]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEB &  RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[13]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEB &  RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[12]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEB &  RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[11]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEB &  RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[10]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEB &  RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[9]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEB &  RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[8]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEB &  RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[7]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEB &  RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[6]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEB &  RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[5]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEB &  RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[4]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEB &  RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[3]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEB &  RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[2]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEB &  RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[1]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEB &  RMB[0] & !RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[0]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RMEB &  !RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[31]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEB &  !RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[30]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEB &  !RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[29]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEB &  !RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[28]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEB &  !RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[27]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEB &  !RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[26]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEB &  !RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[25]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEB &  !RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[24]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEB &  !RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[23]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEB &  !RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[22]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEB &  !RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[21]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEB &  !RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[20]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEB &  !RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[19]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEB &  !RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[18]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEB &  !RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[17]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEB &  !RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[16]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEB &  !RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[15]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEB &  !RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[14]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEB &  !RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[13]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEB &  !RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[12]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEB &  !RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[11]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEB &  !RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[10]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEB &  !RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[9]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEB &  !RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[8]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEB &  !RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[7]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEB &  !RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[6]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEB &  !RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[5]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEB &  !RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[4]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEB &  !RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[3]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEB &  !RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[2]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEB &  !RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[1]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEB &  !RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[0]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RMEB &  RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[31]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RMEB &  RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[30]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RMEB &  RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[29]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RMEB &  RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[28]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RMEB &  RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[27]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RMEB &  RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[26]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RMEB &  RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[25]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RMEB &  RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[24]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RMEB &  RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[23]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RMEB &  RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[22]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RMEB &  RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[21]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RMEB &  RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[20]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RMEB &  RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[19]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RMEB &  RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[18]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RMEB &  RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[17]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RMEB &  RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[16]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RMEB &  RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[15]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RMEB &  RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[14]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RMEB &  RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[13]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RMEB &  RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[12]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RMEB &  RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[11]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RMEB &  RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[10]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RMEB &  RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[9]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RMEB &  RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[8]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RMEB &  RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[7]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RMEB &  RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[6]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RMEB &  RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[5]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RMEB &  RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[4]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RMEB &  RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[3]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RMEB &  RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[2]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RMEB &  RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[1]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RMEB &  RMB[0] & RMB[1] & !RMB[2] & !RMB[3]  )
       ( posedge CLKB => (  QB[0]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );



// Timing Checks

  $width (negedge CLKA &&& ENCLKA, Tcl, 0, notif_clka);
  $width (posedge CLKA &&& ENCLKA, Tch, 0, notif_clka);
  $period (posedge CLKA &&& ENCLKA_rmezo, Tcc, notif_clka);
  $period (negedge CLKA &&& ENCLKA_rmezo, Tcc, notif_clka);
  $period (posedge CLKA &&& ENCLKA_vdm, Tccvddmin, notif_clka);
  $period (negedge CLKA &&& ENCLKA_vdm, Tccvddmin, notif_clka);
  $period (posedge CLKA &&& ENCLKA_slw, Tccslow, notif_clka);
  $period (negedge CLKA &&& ENCLKA_slw, Tccslow, notif_clka);
  $period (posedge CLKA &&& ENCLKA_def, Tccdef, notif_clka);
  $period (negedge CLKA &&& ENCLKA_def, Tccdef, notif_clka);
  $period (posedge CLKA &&& ENCLKA_fst, Tccfast, notif_clka);
  $period (negedge CLKA &&& ENCLKA_fst, Tccfast, notif_clka);
  $width (negedge CLKB &&& ENCLKB, Tcl, 0, notif_clkb);
  $width (posedge CLKB &&& ENCLKB, Tch, 0, notif_clkb);
  $period (posedge CLKB &&& ENCLKB_rmezo, Tcc, notif_clkb);
  $period (negedge CLKB &&& ENCLKB_rmezo, Tcc, notif_clkb);
  $period (posedge CLKB &&& ENCLKB_vdm, Tccvddmin, notif_clkb);
  $period (negedge CLKB &&& ENCLKB_vdm, Tccvddmin, notif_clkb);
  $period (posedge CLKB &&& ENCLKB_slw, Tccslow, notif_clkb);
  $period (negedge CLKB &&& ENCLKB_slw, Tccslow, notif_clkb);
  $period (posedge CLKB &&& ENCLKB_def, Tccdef, notif_clkb);
  $period (negedge CLKB &&& ENCLKB_def, Tccdef, notif_clkb);
  $period (posedge CLKB &&& ENCLKB_fst, Tccfast, notif_clkb);
  $period (negedge CLKB &&& ENCLKB_fst, Tccfast, notif_clkb);

  $setuphold (posedge CLKA  &&& ENADRA, posedge ADRA[0], Tac, Tcax, notif_adra );
  $setuphold (posedge CLKA  &&& ENADRA, negedge ADRA[0], Tac, Tcax, notif_adra );
  $setuphold (posedge CLKA  &&& ENADRA, posedge ADRA[1], Tac, Tcax, notif_adra );
  $setuphold (posedge CLKA  &&& ENADRA, negedge ADRA[1], Tac, Tcax, notif_adra );
  $setuphold (posedge CLKA  &&& ENADRA, posedge ADRA[2], Tac, Tcax, notif_adra );
  $setuphold (posedge CLKA  &&& ENADRA, negedge ADRA[2], Tac, Tcax, notif_adra );
  $setuphold (posedge CLKA  &&& ENADRA, posedge ADRA[3], Tac, Tcax, notif_adra );
  $setuphold (posedge CLKA  &&& ENADRA, negedge ADRA[3], Tac, Tcax, notif_adra );
  $setuphold (posedge CLKA  &&& ENADRA, posedge ADRA[4], Tac, Tcax, notif_adra );
  $setuphold (posedge CLKA  &&& ENADRA, negedge ADRA[4], Tac, Tcax, notif_adra );
  $setuphold (posedge CLKA  &&& ENADRA, posedge ADRA[5], Tac, Tcax, notif_adra );
  $setuphold (posedge CLKA  &&& ENADRA, negedge ADRA[5], Tac, Tcax, notif_adra );
  $setuphold (posedge CLKA  &&& ENADRA, posedge ADRA[6], Tac, Tcax, notif_adra );
  $setuphold (posedge CLKA  &&& ENADRA, negedge ADRA[6], Tac, Tcax, notif_adra );
  $setuphold (posedge CLKA  &&& ENADRA, posedge ADRA[7], Tac, Tcax, notif_adra );
  $setuphold (posedge CLKA  &&& ENADRA, negedge ADRA[7], Tac, Tcax, notif_adra );
  $setuphold (posedge CLKA  &&& ENADRA, posedge ADRA[8], Tac, Tcax, notif_adra );
  $setuphold (posedge CLKA  &&& ENADRA, negedge ADRA[8], Tac, Tcax, notif_adra );
  $setuphold (posedge CLKA  &&& ENADRA, posedge ADRA[9], Tac, Tcax, notif_adra );
  $setuphold (posedge CLKA  &&& ENADRA, negedge ADRA[9], Tac, Tcax, notif_adra );
  $setuphold (posedge CLKA  &&& ENDA, posedge DA[0], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, negedge DA[0], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, posedge DA[1], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, negedge DA[1], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, posedge DA[2], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, negedge DA[2], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, posedge DA[3], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, negedge DA[3], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, posedge DA[4], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, negedge DA[4], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, posedge DA[5], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, negedge DA[5], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, posedge DA[6], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, negedge DA[6], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, posedge DA[7], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, negedge DA[7], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, posedge DA[8], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, negedge DA[8], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, posedge DA[9], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, negedge DA[9], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, posedge DA[10], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, negedge DA[10], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, posedge DA[11], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, negedge DA[11], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, posedge DA[12], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, negedge DA[12], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, posedge DA[13], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, negedge DA[13], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, posedge DA[14], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, negedge DA[14], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, posedge DA[15], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, negedge DA[15], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, posedge DA[16], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, negedge DA[16], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, posedge DA[17], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, negedge DA[17], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, posedge DA[18], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, negedge DA[18], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, posedge DA[19], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, negedge DA[19], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, posedge DA[20], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, negedge DA[20], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, posedge DA[21], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, negedge DA[21], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, posedge DA[22], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, negedge DA[22], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, posedge DA[23], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, negedge DA[23], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, posedge DA[24], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, negedge DA[24], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, posedge DA[25], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, negedge DA[25], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, posedge DA[26], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, negedge DA[26], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, posedge DA[27], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, negedge DA[27], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, posedge DA[28], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, negedge DA[28], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, posedge DA[29], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, negedge DA[29], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, posedge DA[30], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, negedge DA[30], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, posedge DA[31], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENDA, negedge DA[31], Tdc, Tcdx, notif_da );
  $setuphold (posedge CLKA  &&& ENWEA, posedge WEA,Twc, Tcwx, notif_wea );
  $setuphold (posedge CLKA  &&& ENWEA, negedge WEA,Twc, Tcwx, notif_wea );
  $setuphold (posedge CLKA  &&& ENMEA, posedge MEA,Tmc, Tcmx, notif_mea );
  $setuphold (posedge CLKA  &&& ENMEA, negedge MEA,Tmc, Tcmx, notif_mea );
  $hold (negedge CLKA  &&& ENTEST1A, posedge TEST1A, Tct1x, notif_test1a );
  $hold (negedge CLKA  &&& ENTEST1A, negedge TEST1A, Tct1x, notif_test1a );
  $setup ( posedge TEST1A,posedge CLKA  &&& ENTEST1A, Tt1c, notif_test1a );
  $setup ( negedge TEST1A,posedge CLKA  &&& ENTEST1A, Tt1c, notif_test1a );
  $hold (negedge CLKA  &&& ENTEST1A, posedge TEST1A, Tct1x, notif_test1a );
  $hold (negedge CLKA  &&& ENTEST1A, negedge TEST1A, Tct1x, notif_test1a );
  $setup ( posedge TEST1A,posedge CLKA  &&& ENTEST1A, Tt1c, notif_test1a );
  $setup ( negedge TEST1A,posedge CLKA  &&& ENTEST1A, Tt1c, notif_test1a );
  $setuphold (posedge CLKA  &&& ENWMENA, posedge WMENA,Twmec, Tcwmex, notif_wmena );
  $setuphold (posedge CLKA  &&& ENWMENA, negedge WMENA,Twmec, Tcwmex, notif_wmena );
  $setuphold (posedge CLKB  &&& ENADRB, posedge ADRB[0], Tac, Tcax, notif_adrb );
  $setuphold (posedge CLKB  &&& ENADRB, negedge ADRB[0], Tac, Tcax, notif_adrb );
  $setuphold (posedge CLKB  &&& ENADRB, posedge ADRB[1], Tac, Tcax, notif_adrb );
  $setuphold (posedge CLKB  &&& ENADRB, negedge ADRB[1], Tac, Tcax, notif_adrb );
  $setuphold (posedge CLKB  &&& ENADRB, posedge ADRB[2], Tac, Tcax, notif_adrb );
  $setuphold (posedge CLKB  &&& ENADRB, negedge ADRB[2], Tac, Tcax, notif_adrb );
  $setuphold (posedge CLKB  &&& ENADRB, posedge ADRB[3], Tac, Tcax, notif_adrb );
  $setuphold (posedge CLKB  &&& ENADRB, negedge ADRB[3], Tac, Tcax, notif_adrb );
  $setuphold (posedge CLKB  &&& ENADRB, posedge ADRB[4], Tac, Tcax, notif_adrb );
  $setuphold (posedge CLKB  &&& ENADRB, negedge ADRB[4], Tac, Tcax, notif_adrb );
  $setuphold (posedge CLKB  &&& ENADRB, posedge ADRB[5], Tac, Tcax, notif_adrb );
  $setuphold (posedge CLKB  &&& ENADRB, negedge ADRB[5], Tac, Tcax, notif_adrb );
  $setuphold (posedge CLKB  &&& ENADRB, posedge ADRB[6], Tac, Tcax, notif_adrb );
  $setuphold (posedge CLKB  &&& ENADRB, negedge ADRB[6], Tac, Tcax, notif_adrb );
  $setuphold (posedge CLKB  &&& ENADRB, posedge ADRB[7], Tac, Tcax, notif_adrb );
  $setuphold (posedge CLKB  &&& ENADRB, negedge ADRB[7], Tac, Tcax, notif_adrb );
  $setuphold (posedge CLKB  &&& ENADRB, posedge ADRB[8], Tac, Tcax, notif_adrb );
  $setuphold (posedge CLKB  &&& ENADRB, negedge ADRB[8], Tac, Tcax, notif_adrb );
  $setuphold (posedge CLKB  &&& ENADRB, posedge ADRB[9], Tac, Tcax, notif_adrb );
  $setuphold (posedge CLKB  &&& ENADRB, negedge ADRB[9], Tac, Tcax, notif_adrb );
  $setuphold (posedge CLKB  &&& ENMEB, posedge MEB,Tmc, Tcmx, notif_meb );
  $setuphold (posedge CLKB  &&& ENMEB, negedge MEB,Tmc, Tcmx, notif_meb );
  $hold (negedge CLKB  &&& ENTEST1B, posedge TEST1B, Tct1x, notif_test1b );
  $hold (negedge CLKB  &&& ENTEST1B, negedge TEST1B, Tct1x, notif_test1b );
  $setup ( posedge TEST1B,posedge CLKB  &&& ENTEST1B, Tt1c, notif_test1b );
  $setup ( negedge TEST1B,posedge CLKB  &&& ENTEST1B, Tt1c, notif_test1b );
  $hold (negedge CLKB  &&& ENTEST1B, posedge TEST1B, Tct1x, notif_test1b );
  $hold (negedge CLKB  &&& ENTEST1B, negedge TEST1B, Tct1x, notif_test1b );
  $setup ( posedge TEST1B,posedge CLKB  &&& ENTEST1B, Tt1c, notif_test1b );
  $setup ( negedge TEST1B,posedge CLKB  &&& ENTEST1B, Tt1c, notif_test1b );
  $setuphold (posedge CLKA  &&& ENRMA, posedge RMB[0], Trmc, Tcrmx, notif_rmb_a );
  $setuphold (posedge CLKA  &&& ENRMA, negedge RMB[0], Trmc, Tcrmx, notif_rmb_a );
  $setuphold (posedge CLKA  &&& ENRMA, posedge RMB[1], Trmc, Tcrmx, notif_rmb_a );
  $setuphold (posedge CLKA  &&& ENRMA, negedge RMB[1], Trmc, Tcrmx, notif_rmb_a );
  $setuphold (posedge CLKA  &&& ENRMA, posedge RMB[2], Trmc, Tcrmx, notif_rmb_a );
  $setuphold (posedge CLKA  &&& ENRMA, negedge RMB[2], Trmc, Tcrmx, notif_rmb_a );
  $setuphold (posedge CLKA  &&& ENRMA, posedge RMB[3], Trmc, Tcrmx, notif_rmb_a );
  $setuphold (posedge CLKA  &&& ENRMA, negedge RMB[3], Trmc, Tcrmx, notif_rmb_a );
  $setuphold (posedge CLKB  &&& ENRMB, posedge RMB[0], Trmc, Tcrmx, notif_rmb );
  $setuphold (posedge CLKB  &&& ENRMB, negedge RMB[0], Trmc, Tcrmx, notif_rmb );
  $setuphold (posedge CLKB  &&& ENRMB, posedge RMB[1], Trmc, Tcrmx, notif_rmb );
  $setuphold (posedge CLKB  &&& ENRMB, negedge RMB[1], Trmc, Tcrmx, notif_rmb );
  $setuphold (posedge CLKB  &&& ENRMB, posedge RMB[2], Trmc, Tcrmx, notif_rmb );
  $setuphold (posedge CLKB  &&& ENRMB, negedge RMB[2], Trmc, Tcrmx, notif_rmb );
  $setuphold (posedge CLKB  &&& ENRMB, posedge RMB[3], Trmc, Tcrmx, notif_rmb );
  $setuphold (posedge CLKB  &&& ENRMB, negedge RMB[3], Trmc, Tcrmx, notif_rmb );
  $setuphold (posedge CLKB  &&& ENRMEB, posedge RMEB,Trmc, Tcrmx, notif_rmeb );
  $setuphold (posedge CLKB  &&& ENRMEB, negedge RMEB,Trmc, Tcrmx, notif_rmeb );
  $recovery ( posedge CLKA,posedge CLKB  &&& ENCLKACLKBrec, Tcsep, notif_clka_CLKB_rise_rise_rec);
  $recovery ( posedge CLKB,posedge CLKA  &&& ENCLKBCLKArec, Tcsep, notif_clkb_CLKA_rise_rise_rec);

endspecify
`endif // VIRAGE_FAST_VERILOG






`ifdef VIRAGE_FAST_VERILOG

generic_behav_ram1kx32_2p1r1w #(MES_ALL ,debug_mode) u0 (  .QB (QB_buf), .ADRA (ADRA_buf), .DA (DA_buf), .WEA(WEA_buf), .MEA(MEA_buf), .CLKA(CLKA_buf), .TEST1A(TEST1A_buf), .WMENA(WMENA_buf), .ADRB (ADRB_buf), .MEB(MEB_buf), .CLKB(CLKB_buf), .TEST1B(TEST1B_buf), .RMB (RMB_buf), .RMEB(RMEB_buf) );

`else

generic_behav_ram1kx32_2p1r1w #(MES_ALL ,debug_mode) u0 (  .QB (QB_buf), .ADRA (ADRA_buf), .DA (DA_buf), .WEA(WEA_buf), .MEA(MEA_buf), .CLKA(CLKA_buf), .TEST1A(TEST1A_buf), .WMENA(WMENA_buf), .ADRB (ADRB_buf), .MEB(MEB_buf), .CLKB(CLKB_buf), .TEST1B(TEST1B_buf), .RMB (RMB_buf), .RMEB(RMEB_buf), .CLKB_tcq (CLKB_tcq),.notif_adra(notif_adra), .notif_da(notif_da), .notif_wea(notif_wea), .notif_mea(notif_mea), .notif_clka(notif_clka), .notif_clka_CLKB_rise_rise_rec(notif_clka_CLKB_rise_rise_rec), .notif_test1a(notif_test1a), .notif_wmena(notif_wmena), .notif_adrb(notif_adrb), .notif_meb(notif_meb), .notif_clkb(notif_clkb), .notif_clkb_CLKA_rise_rise_rec(notif_clkb_CLKA_rise_rise_rec), .notif_test1b(notif_test1b), .notif_rmb(notif_rmb), .notif_rmb_a(notif_rmb_a), .notif_rmeb(notif_rmeb) );

`endif // VIRAGE_FAST_VERILOG


always @( ADRA_buf or negedge CLKA_buf)
 begin
   if ( CLKA_buf == 1'b0) ADRA_pre = ADRA_buf;
 end

always @( MEA_buf or negedge CLKA_buf)
  begin
    if ( CLKA_buf == 1'b0) MEA_pre = MEA_buf;
  end

always @( WEA_buf or negedge CLKA_buf)
  begin
    if ( CLKA_buf == 1'b0) WEA_pre = WEA_buf;
  end
real CLKA_UTIME;
real CLKB_UTIME;

always @( posedge CLKA_buf)
begin
    MEA_buf_L = MEA_pre;
    WEA_buf_L = WEA_pre;
  `ifdef VIRAGE_FAST_VERILOG
  `else

    CLKA_UTIME = $realtime;
    ADRA_buf_L = ADRA_pre;
    #0;

    if (CLKA_UTIME == CLKB_UTIME)
    begin
    #0;
      if (((ADRA_buf_L === ADRB_buf_L) && ADRA_valid_rec) || (CLKA_buf === 1'bx || CLKB_buf === 1'bx) || ((ADRA_buf_L^ADRA_buf_L) !== 0) || ((ADRB_buf_L^ADRB_buf_L) !== 0))
      begin
         if ((MEA_buf_L !== 1'b0 && MEB_buf_L !== 1'b0) && (recovery_ab == 1'b1))
         begin

           if(MES_ALL=="ON" && $realtime != 0 && u0.mes_all_valid == 1'b1)
           begin
             $display("\n%m VIRL_MEM_WARNING: Entered recovery block (posedge CLKA,posedge CLKB) (time %t)", $time);
           end // end of if(MES_ALL=="ON" && $realtime != 0 

           if(notif_clkb_CLKA_rise_rise_rec === 1'bx)
             notif_clkb_CLKA_rise_rise_rec = 1'b0;
           else
             notif_clkb_CLKA_rise_rise_rec = !notif_clkb_CLKA_rise_rise_rec;
         end 
      end
    end //end of if (u0.CLKA_UTIME == u0.CLKB_UTIME)

    `endif // VIRAGE_FAST_VERILOG
end  // end of always @( posedge CLKA_buf)

always @( ADRB_buf or negedge CLKB_buf)
 begin
   if ( CLKB_buf == 1'b0) ADRB_pre = ADRB_buf;
 end

always @( MEB_buf or negedge CLKB_buf)
  begin
    if ( CLKB_buf == 1'b0) MEB_pre = MEB_buf;
  end


always @( posedge CLKB_buf)
begin
    MEB_buf_L = MEB_pre;
  `ifdef VIRAGE_FAST_VERILOG
  `else

    CLKB_tcq = 1'b1;
    CLKB_UTIME = $realtime;
    ADRB_buf_L = ADRB_pre;
    #0;

    if (CLKB_UTIME == CLKA_UTIME)
    begin
    #0;
      if (((ADRB_buf_L === ADRA_buf_L) && ADRB_valid_rec) || (CLKB_buf === 1'bx || CLKA_buf === 1'bx) || ((ADRB_buf_L^ADRB_buf_L) !== 0) || ((ADRA_buf_L^ADRA_buf_L) !== 0))
      begin
         if ((MEB_buf_L !== 1'b0 && MEA_buf_L !== 1'b0) && (recovery_ab == 1'b1))
         begin

           if(MES_ALL=="ON" && $realtime != 0 && u0.mes_all_valid == 1'b1)
           begin
             $display("\n%m VIRL_MEM_WARNING: Entered recovery block (posedge CLKB,posedge CLKA) (time %t)", $time);
           end // end of if(MES_ALL=="ON" && $realtime != 0 

           if(notif_clka_CLKB_rise_rise_rec === 1'bx)
             notif_clka_CLKB_rise_rise_rec = 1'b0;
           else
             notif_clka_CLKB_rise_rise_rec = !notif_clka_CLKB_rise_rise_rec;
         end 
      end
    end //end of if (u0.CLKB_UTIME == u0.CLKA_UTIME)

    `endif // VIRAGE_FAST_VERILOG
end  // end of always @( posedge CLKB_buf)





endmodule
`endcelldefine 
`ifdef verifault 
`disable_portfaults 
`nosuppress_faults 
`endif 


`ifdef VIRAGE_FAST_VERILOG

module generic_behav_ram1kx32_2p1r1w (  QB, ADRA, DA, WEA, MEA, CLKA, TEST1A, WMENA, ADRB, MEB, CLKB, TEST1B, RMB, RMEB );

`else

module generic_behav_ram1kx32_2p1r1w (  QB, ADRA, DA, WEA, MEA, CLKA, TEST1A, WMENA, ADRB, MEB, CLKB, TEST1B, RMB, RMEB, CLKB_tcq,notif_adra, notif_da, notif_wea, notif_mea, notif_clka, notif_clka_CLKB_rise_rise_rec, notif_test1a, notif_wmena, notif_adrb, notif_meb, notif_clkb, notif_clkb_CLKA_rise_rise_rec, notif_test1b, notif_rmb, notif_rmb_a, notif_rmeb );

`endif //VIRAGE_FAST_VERILOG

 parameter MES_ALL = "ON";
parameter debug_mode = 1;
parameter words = 1024, bits = 32, addrbits = 10, timingmode = 1, rmbits=4;

output [bits-1:0] QB;
input [addrbits-1:0] ADRA;
input [bits-1:0] DA;
input WEA;
input MEA;
input CLKA;
input TEST1A;
input WMENA;
input [addrbits-1:0] ADRB;
input MEB;
input CLKB;
input TEST1B;
input [rmbits-1:0] RMB;
input RMEB;


    `ifdef  virage_ignore_read_addx
       parameter flag_ignore_read_addx = 0;
    `else
       parameter flag_ignore_read_addx = 1;
    `endif

`ifdef VIRAGE_FAST_VERILOG
`else
input CLKB_tcq;
input notif_adra, notif_da, notif_wea, notif_mea, notif_clka, notif_clka_CLKB_rise_rise_rec, notif_test1a, notif_wmena, notif_adrb, notif_meb, notif_clkb, notif_clkb_CLKA_rise_rise_rec, notif_test1b, notif_rmb, notif_rmb_a, notif_rmeb;

`endif // VIRAGE_FAST_VERILOG

parameter DataX = { bits { 1'bx } };
parameter DataZ = { bits { 1'bz } };

reg  [bits-1:0]  QB_local;
wire [bits-1:0]  QB_blk;
reg [bits-1:0]  QB;

wire    [3:0] WMENA_set;
reg
        flaga_we_ok,
        flaga_d_ok,
        flaga_adr_ok,
        flaga_range_ok;
reg     flaga_clk_valid;
reg     flaga_adr_x;

reg  [addrbits-1:0] ADRAlatched;
reg  [addrbits-1:0] ADRA_old;
reg  [bits-1:0] DAlatched;
reg  [bits-1:0] DA_old;
reg WEAlatched;
reg WEA_old;
reg  TEST1Alatched;
reg  TEST1A_old;
reg  MEAlatched;
reg  MEA_old;
reg  MEA_chk;
real CLKA_TIME;
wire    [3:0] RMB_set;
reg
        flagb_read_ok,
        flagb_rm_ok,
        flagb_adr_ok,
        flagb_range_ok;
reg     flagb_clk_valid;
reg     flagb_adr_x;

event   event_on_B_port;

reg  [addrbits-1:0] ADRBlatched;
reg  [addrbits-1:0] ADRB_old;
reg  TEST1Blatched;
reg  TEST1B_old;
reg  MEBlatched;
reg  MEB_old;
reg  MEB_chk;
real CLKB_TIME;

`ifdef VIRAGE_FAST_VERILOG
`else

real CLKB_tcqtime;

always @(negedge CLKB_tcq) begin
   CLKB_tcqtime = $realtime;
end
`endif // VIRAGE_FAST_VERILOG

integer i;
reg  [bits-1:0] mem_core_array [0:words -1];
reg  [bits-1:0] mem_fault_array_XOR [0:words -1];
initial 
  begin
    for (i=0; i< words ; i=i+1)
      mem_fault_array_XOR[i]=0;
`ifdef MEMFAULTINJ
    if ($test$plusargs("asap_error"))
      mem_fault_array_XOR[1] = 1'b1 << (bits - 1);
`endif
  end


reg mes_all_valid;

initial
begin
  mes_all_valid = 0;
  MEA_chk = 1'b0;
  MEB_chk = 1'b0;
end

function is_adr_Valid;  // 1-bit return value
 input [addrbits-1:0] addr_to_check;
 reg     ret_value;
 begin
  ret_value = `True;
   if ((^addr_to_check) === 1'bx ) begin
    flaga_adr_x = `True;
    flagb_adr_x = `True;
    ret_value = `False;
   end
   if((addr_to_check > words -1) )
    begin
     ret_value = `False;
    end
   is_adr_Valid = ret_value;
end
endfunction

// -------------------------------------------------------------------
// Common tasks
// -------------------------------------------------------------------

// Task to report unknown messages
task report_unknown;
input [8*6:1] signal;
begin
    if( MES_ALL=="ON" && $realtime != 0 && mes_all_valid )
    begin
      $display("<<%0s unknown>> at time=%t; instance=%m (RAMS1H)",signal,$realtime);
    end
end
endtask


task corrupt_all_loc;
 input flag_range_ok;
 integer addr_index;
 begin
                                     // do not corrupt entire memory if write to
                                    // out of range address, for all other cases
                                    // flag_range_ok is true, therefore corruption
                                    // will occur as before
  if( flag_range_ok == `True)
   begin
    for( addr_index = 0; addr_index < words; addr_index = addr_index + 1) begin
     mem_core_array[ addr_index] = DataX;
    end
   end
 end
endtask

task corrupt_cur_loc;
 input[addrbits-1:0] loc_to_corrupt;
  mem_core_array[loc_to_corrupt] = DataX;
endtask


always @( negedge CLKA or WEA )
   begin
       if ( CLKA == 1'b0 )
       WEA_old = WEA;
   end
always @( negedge CLKA or ADRA )
   begin
       if ( CLKA == 1'b0 )
       ADRA_old = ADRA;
   end
always @( negedge CLKA or DA )
   begin
       if ( CLKA == 1'b0 )
       DA_old = DA;
   end
always @( negedge CLKA or MEA )
   begin
       if ( CLKA == 1'b0 )
       MEA_old = MEA;
   end
always @( negedge CLKA or TEST1A )
   begin
       if ( CLKA == 1'b0 )
       TEST1A_old = TEST1A;
   end
// Perform Sanity Check on Port A, Corrupt memory if required

task checkSanityOnAport;

 #0                // let CLOCK and NOTIFIER stuff execute first
 case ( {flaga_adr_ok, flaga_we_ok, flaga_d_ok} ) // only 1 and 0

  3'b111   : ;                                                // everything ok!!!

  3'b101,
  3'b100   : corrupt_cur_loc(ADRAlatched);          // WE is unstable

  3'b110   : if (WEAlatched !== 1'b0)
              corrupt_cur_loc(ADRAlatched);         // Data is unstable
  3'b000,
  3'b001   : corrupt_all_loc(flaga_range_ok);            // ADR and WE unstable
  3'b010,
  3'b011   : if (WEAlatched !== 1'b0)    // ADR unstable, WE stable
              corrupt_all_loc(flaga_range_ok);
 endcase
endtask

// PORT A FUNCTIONALITY (Handle violation behavior)

initial
 begin
  flaga_adr_ok  = `True;
  flaga_range_ok = `True;
  flaga_we_ok   = `True;
  flaga_d_ok    = `True;
  flaga_clk_valid = `True;
  flaga_adr_x = `False;
 end


`ifdef VIRAGE_FAST_VERILOG
`else

always @(notif_wea)            // PORT A WE violation
 begin

    flaga_we_ok = `False;
    checkSanityOnAport;
 end
always @(notif_clka)            // PORT A CLK violation
 begin

  if ( $realtime == CLKB_TIME )
   MEB_chk = MEB_old;
  else
   MEB_chk = MEBlatched;

  if ( CLKB_tcq == 1'b1 && MEB_chk === 1'b1 )
   begin
    disable OUTPUT_1;
    flagb_read_ok = `False;
    -> event_on_B_port;
   end
  flaga_adr_ok = `False;
  flaga_we_ok  = `False;
  checkSanityOnAport;
 end

always @(notif_mea)            // PORT A ME violation
 begin

  if ( $realtime == CLKB_TIME )
   MEB_chk = MEB_old;
  else
   MEB_chk = MEBlatched;

  if (MEB_chk === 1'b1 && (CLKB_tcq == 1'b1 || (CLKB_tcqtime == $realtime)))
   begin
    disable OUTPUT_1;
    flagb_read_ok = `False;
    -> event_on_B_port;
   end
  flaga_adr_ok = `False;
  checkSanityOnAport;
  corrupt_all_loc(`True);
 end


always @(notif_adra)           // PORT A ADR violation
 begin

    if (MEBlatched === 1'b1 && WEAlatched === 1'b1 && (CLKB_tcq == 1'b1 || (CLKB_tcqtime == $realtime)))
     begin
      disable OUTPUT_1;
      flagb_read_ok = `False;
      -> event_on_B_port;
     end
    flaga_adr_ok = `False;
    checkSanityOnAport;
 end

always @(notif_da)             // PORT A D violation
 begin

    flaga_d_ok = `False;
    checkSanityOnAport;
 end

always @(notif_test1a)               //PORT A TEST1 violation
 begin
    flaga_d_ok  = `False;
    checkSanityOnAport;
 end
always @(notif_rmb_a)               //PORT A RM violation
 begin
    flaga_d_ok  = `False;
    checkSanityOnAport;
 end
always @(notif_wmena)               //PORT A WMEN violation
 begin
    flaga_d_ok  = `False;
    checkSanityOnAport;
 end



always @(notif_clka_CLKB_rise_rise_rec)
 begin

      flagb_read_ok = `False;
      disable OUTPUT_1;
      -> event_on_B_port;
 end
`endif // VIRAGE_FAST_VERILOG


always @(negedge CLKA)          // reset for next cycle
 begin
  if ( CLKA !== 1'bx ) begin
   #0.001;
   flaga_range_ok  = `True;
   flaga_clk_valid = `True;
   flaga_adr_x = `False;
  end
  else
  begin
    report_unknown("CLKA");
    flaga_clk_valid = `False;
    corrupt_all_loc(`True);
   end
 end

// PORT A FUNCTIONALITY (Handle normal read/write)

always @(posedge CLKA)
begin
  flaga_adr_ok  = `True;
  flaga_we_ok   = `True;
  flaga_d_ok    = `True;

  if (CLKA === 1'bx)
  begin
    report_unknown("CLKA");
    flaga_clk_valid = `False;
    corrupt_all_loc(`True);
  end // end of if (CLKA === 1'bx)

  CLKA_TIME = $realtime;
  MEAlatched = MEA_old;
  WEAlatched = WEA_old;
  TEST1Alatched = TEST1A_old;
  ADRAlatched = ADRA_old;
  DAlatched = DA_old;
    if ((^DAlatched === 1'bx) && MEAlatched == 1'b1)
    begin
      if (DAlatched === 32'bx)
      begin
        flaga_d_ok  = `False;
      end
      if (WEAlatched !== 1'b0)
      begin
        report_unknown("DA");
      end  
    end



  if ( CLKA === 1'bx ) 
  begin
    report_unknown("CLKA");
    corrupt_all_loc(flaga_range_ok);
  end
  else if (flaga_clk_valid)
  begin
    if (MEAlatched!== 1'b0)
    begin
      if (TEST1Alatched === 1'bx)
      begin
        report_unknown("TEST1A");
        if (WEAlatched === 1'b1)
        begin
          flaga_adr_ok = `False;
        end
      end
      if (WEAlatched === 1'bx)
      begin
        report_unknown("WEA");
        flaga_we_ok = `False;
      end
      if (MEAlatched !== 1'b1)
       flaga_we_ok = `False;       // don't know if cycle is On or Off
      if (is_adr_Valid(ADRAlatched) != `True ) begin
       if ( flaga_adr_x ) begin
         report_unknown("ADRA");
       end
       flaga_adr_ok = `False;
       if( !(flaga_adr_x) )
       begin
         if( MES_ALL=="ON" && $realtime != 0 && mes_all_valid == 1'b1)
         $display("\n%m VIRL_MEM_WARNING:address ADRA is out of range, RANGE:0 to 1023\n");
         flaga_range_ok = `False;
       end
      end

      if ( MEAlatched === 1'bx )
      begin
         report_unknown("MEA");
            corrupt_all_loc(flaga_range_ok);
      end
      else
      begin
        if ((WMENA_set != 4'b0010) && WEAlatched == 1'b1 && MEAlatched == 1'b1)
        begin
          if( MES_ALL=="ON" && $realtime != 0 && mes_all_valid == 1'b1)
          begin
            $display("VIRL_MEM_WARNING: RMB = %b is not recommended value in Write mode\n",RMB);
            $display("      time=%t; instance=%m (ram1kx32_2p1r1w_core)",$realtime);
          end
        end // WMENA != 4'b0010
        if (WEAlatched == 1'b1 && MEAlatched == 1'b1)
        begin
          if (^WMENA === 1'bX)
          begin
            flaga_we_ok = `False;
            report_unknown("WMENA");
          end
        end
         if (flaga_we_ok && flaga_adr_ok && flaga_d_ok && (WEAlatched == 1'b1))
         begin
           mem_core_array[ADRAlatched] = DAlatched;  // write data in
           if (mes_all_valid == 0) mes_all_valid = 1;
	 end
         else
         begin
           checkSanityOnAport;
         end

  `ifdef VIRAGE_FAST_VERILOG
//-- Simultaneous Contention case
        #0.0;
        if(CLKA_TIME==CLKB_TIME)
        begin
          if((ADRAlatched===ADRBlatched) && ((MEAlatched && MEBlatched) || (WEAlatched && ((MEAlatched===1'bx && MEBlatched) || (MEAlatched && MEBlatched===1'bx)))))
          begin
            if(WEAlatched!==1'b0)
            begin
              if(MEBlatched)
              begin
                if(MES_ALL=="ON" && debug_mode == 1 ) 
                begin
                  $display("VIRL_MEM_WARNING: <<Simultaneous access to the same address on B-port(READ) and A-port(WRITE)>> time = %t, instance = %m (RAMS1H)",$realtime);
                end // end of if(MES_ALL=="ON")

                #0 QB_local <=  DataX;
              end
            end
      end
    end
  `endif // VIRAGE_FAST_VERILOG 

       end
     end
   end
 end





always @ (TEST1A)
begin
  if ( CLKA === 1'b1 && MEAlatched === 1'b1 )
  begin
    if (WEAlatched === 1'b1 )
    begin
      corrupt_cur_loc(ADRAlatched);
    end
    QB_local = 32'bx;
    flagb_read_ok = `False;
  end
  if ( TEST1A == 1'b1)
  begin
    if(MES_ALL=="ON" && $realtime != 0 && mes_all_valid)
    begin
      $display("\n%m VERILOG> VIRL_MEM_WARNING: Tcc value in the RAM model is for TEST1A=1'b0,but input value is TEST1A=1'b1 (time %0t)\n\n", $time);
    end
  end
end


always @ (TEST1A)
begin
  if ( TEST1A == 1'b1)
  begin
    if( MES_ALL=="ON" && $realtime != 0 && mes_all_valid)
    begin
      $display("\n%m VERILOG> VIRL_MEM_WARNING: Tcc value in the RAM model is for TEST1A=1'b0, but input value is TEST1A=1'b1 (time %0t)", $time);
    end
  end
end // end of TEST1A

always @( negedge CLKB or ADRB )
   begin
       if ( CLKB == 1'b0 )
       ADRB_old = ADRB;
   end
always @( negedge CLKB or MEB )
   begin
       if ( CLKB == 1'b0 )
       MEB_old = MEB;
   end
always @( negedge CLKB or TEST1B )
   begin
       if ( CLKB == 1'b0 )
       TEST1B_old = TEST1B;
   end

// PORT B FUNCTIONALITY (Handle violation behavior)

initial
 begin
  flagb_adr_ok  = `True;
  flagb_range_ok = `True;
  flagb_read_ok = `True;
  flagb_rm_ok = `True;
  flagb_clk_valid = `True;
  flagb_adr_x = `False;
 end


`ifdef VIRAGE_FAST_VERILOG
`else

always @(notif_clkb)            // PORT B CLK violation
 begin

  if ( $realtime == CLKA_TIME )
   MEA_chk = MEA_old;
  else
   MEA_chk = MEAlatched;
  disable OUTPUT_1;
  flagb_adr_ok = `False;
  if ( MEA_chk === 1'b1 ) begin
   flaga_adr_ok = `False;
   flaga_we_ok  = `False;
   checkSanityOnAport;
  end
  flagb_read_ok = `False;     // irrespective of WE
  -> event_on_B_port;
 end

always @(notif_meb)            // PORT B ME violation
 begin

  flagb_adr_ok = `False;
  flagb_read_ok = `False;     // irrespective of WE
  disable OUTPUT_1;
  -> event_on_B_port;
  corrupt_all_loc(`True);
 end


always @(notif_adrb)           // PORT B ADR violation
 begin

    flagb_adr_ok = `False;
    flagb_read_ok = `False; // irrespective of WE
    disable OUTPUT_1;
    -> event_on_B_port;
  corrupt_all_loc(`True);
 end


always @(notif_test1b)               //PORT B TEST1 violation
 begin
    disable OUTPUT_1;
    flagb_read_ok = `False;
    -> event_on_B_port;
 end

always @(notif_rmb)               //PORT B RM violation
 begin
    disable OUTPUT_1;
    flagb_read_ok = `False;
    -> event_on_B_port;
 end
always @(notif_rmeb)               //PORT B RMEN violation
 begin
    disable OUTPUT_1;
    flagb_read_ok = `False;
    -> event_on_B_port;
 end



always @(notif_clkb_CLKA_rise_rise_rec)
 begin

      flagb_read_ok = `False;
      disable OUTPUT_1;
      -> event_on_B_port;
 end
`endif // VIRAGE_FAST_VERILOG


always @(negedge CLKB)          // reset for next cycle
 begin
  if ( CLKB !== 1'bx ) begin
   #0.001;
   flagb_range_ok  = `True;
   flagb_read_ok = `True;
   flagb_rm_ok = `True;
   flagb_clk_valid = `True;
   flagb_adr_x = `False;
  end
  else
  begin
    report_unknown("CLKB");
    flagb_clk_valid = `False;
    QB_local =  DataX;
    corrupt_all_loc(`True);
   end
 end

// PORT B FUNCTIONALITY (Handle normal read/write)

always @(posedge CLKB)
begin
  flagb_adr_ok  = `True;

  if (CLKB === 1'bx)
  begin
    report_unknown("CLKB");
    flagb_clk_valid = `False;
    QB_local =  DataX;
    corrupt_all_loc(`True);
  end // end of if (CLKB === 1'bx)

  CLKB_TIME = $realtime;
  MEBlatched = MEB_old;
  TEST1Blatched = TEST1B_old;
  ADRBlatched = ADRB_old;


  if (!flagb_clk_valid) begin
    QB_local =  DataX;
  end 
  else
  begin
    if (MEBlatched!== 1'b0)
    begin
      if (TEST1Blatched === 1'bx)
      begin
        report_unknown("TEST1B");
        QB_local = 32'bx;
        flagb_read_ok = `False;
      end
      if (is_adr_Valid(ADRBlatched) != `True ) begin
       if ( flagb_adr_x ) begin
         report_unknown("ADRB");
        if (flag_ignore_read_addx == 1)
         corrupt_all_loc(flagb_range_ok);
       end
       flagb_adr_ok = `False;
       if( !(flagb_adr_x) )
       begin
         if( MES_ALL=="ON" && $realtime != 0 && mes_all_valid == 1'b1)
         $display("\n%m VIRL_MEM_WARNING:address ADRB is out of range, RANGE:0 to 1023\n");
         flagb_range_ok = `False;
       end
      end

      if ( MEBlatched === 1'bx )
      begin
         report_unknown("MEB");
          QB_local =  DataX;
          if (flag_ignore_read_addx == 1)
            corrupt_all_loc(flagb_range_ok);
      end
      else
      begin

  `ifdef VIRAGE_FAST_VERILOG
//-- Simultaneous Contention case
        #0.0;
        if(CLKB_TIME==CLKA_TIME)
        begin
          if((ADRBlatched===ADRAlatched) && ((MEBlatched && MEAlatched) || (WEAlatched && ((MEBlatched===1'bx && MEAlatched) || (MEBlatched && MEAlatched===1'bx)))))
          begin
            if(WEAlatched!==1'b0)
            begin
              if(MEBlatched)
              begin
                if(MES_ALL=="ON" && debug_mode == 1 ) 
                begin
                  $display("VIRL_MEM_WARNING: <<Simultaneous access to the same address on B-port(READ) and A-port(WRITE)>> time = %t, instance = %m (RAMS1H)",$realtime);
                end // end of if(MES_ALL=="ON")

                #0 QB_local <=  DataX;
              end
            end
      end
    end
  `endif // VIRAGE_FAST_VERILOG 

        if (TEST1Blatched == 1 )
        begin
          #0.001;
          flagb_read_ok = `False;
          -> event_on_B_port;
          @(negedge CLKB)
          if ((MEAlatched === MEBlatched) && (ADRAlatched === ADRBlatched) && WEAlatched === 1'b1)
          flagb_read_ok = `False;
          -> event_on_B_port;
        end
        else
        -> event_on_B_port;
       end
     end
   end
 end


// START OF PORT B READ-OUT BLOCK 

always @(event_on_B_port)
begin
  #0 // let CLOCK and NOTIFIER module execute first
  if (RMEB === 1'b1)
  begin
    if (RMB_set >= 4'b0100)
    begin
      if( MES_ALL=="ON" && $realtime != 0 && mes_all_valid == 1'b1)
      begin
       $display("VIRL_MEM_WARNING: RMB = %b is not recommended value ; time = %t, instance = %m (ram1kx32_2p1r1w_core)",RMB,$realtime);
      end
    end
  end
  else
  begin
  if (RMB_set != 4'b0010)
  begin
    if( MES_ALL=="ON" && $realtime != 0 && mes_all_valid == 1'b1)
    begin
      $display("VIRL_MEM_WARNING: RMB = %b is not recommended value in Read Mode ; time = %t, instance = %m (ram1kx32_2p1r1w_core)",RMB,$realtime);
    end // MES_ALL=="ON"
  end // RMB_set != 4'b0010
  end
  if (^RMB_set === 1'bx) begin
    flagb_rm_ok = `False;
    if (RMEB !== 1'bx) begin
      report_unknown("RMB");
    end
  end
    if (flagb_adr_ok && (ADRBlatched <= words -1) && flagb_read_ok && flagb_rm_ok) begin : OUTPUT_1
        `ifdef VIRAGE_FAST_VERILOG
        `else
           QB_local = DataX;
        `endif // VIRAGE_FAST_VERILOG
          `ifdef VIRAGE_FAST_VERILOG
          `else
             #0.001
          `endif // VIRAGE_FAST_VERILOG
          
            QB_local = mem_core_array[ADRBlatched]^mem_fault_array_XOR[ADRBlatched];

            if (mes_all_valid == 0) mes_all_valid = 1;
    end // end of if (flagb_adr_ok && (ADRBlatched))
    else
    begin
        QB_local =   DataX;
        flagb_read_ok = `True;
   end
end // end of always @(event_on_B_port

// END OF PORT B READ-OUT BLOCK



assign QB_blk = QB_local;


always @(QB_blk)
begin : nonblocking_blk_1
   QB <= QB_blk;
end


// START OF PORT B OUTPUT ENABLE BLOCK



always @ (TEST1B)
begin
  if ( CLKB === 1'b1 && MEBlatched === 1'b1 )
  begin
    QB_local = 32'bx;
    flagb_read_ok = `False;
  end
  if ( TEST1B == 1'b1)
  begin
    if(MES_ALL=="ON" && $realtime != 0 && mes_all_valid)
    begin
      $display("\n%m VERILOG> VIRL_MEM_WARNING: Tcc value in the RAM model is for TEST1B=1'b0,but input value is TEST1B=1'b1 (time %0t)\n\n", $time);
    end
  end
end


always @ (TEST1B)
begin
  if ( TEST1B == 1'b1)
  begin
    if( MES_ALL=="ON" && $realtime != 0 && mes_all_valid)
    begin
      $display("\n%m VERILOG> VIRL_MEM_WARNING: Tcc value in the RAM model is for TEST1B=1'b0, but input value is TEST1B=1'b1 (time %0t)", $time);
    end
  end
end // end of TEST1B

assign RMB_set = (RMEB === 1'b0) ? 4'b0010:((RMEB === 1'b1) ? RMB: 4'bx);
assign WMENA_set = (WMENA === 1'b0) ? 4'b0010:((WMENA === 1'b1) ? RMB: 4'bx);
endmodule

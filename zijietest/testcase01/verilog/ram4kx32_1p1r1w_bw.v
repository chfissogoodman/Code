//==================================================================================//
// Author: GWX Technology
// Attribution: Verilog-HDL
// Birthday: Tue Oct 10 15:44:31 CST 2023
// Organization: GWX Technology
// Copyright: GWX Technology Â©2023 GWX Technology Inc. All rights reserved.
//----------------------------------------------------------------------------------//
// Description:
// All the data in the file was generated by GWX Technology. This information was
// prepared only for EDA tools training. GWX Technology does not guarantee the
// accuracy or completeness of the information contained herein. GWX Technology
// shall not be liable for any loss or damage of any kind arising from the use of
// this document or the information contained herein.
//----------------------------------------------------------------------------------//
// Version: 0.9.0.0 Alpha
//==================================================================================//

//   --------------------------------------------------------------     
//                       Template Revision : 3.6.3                      
//   --------------------------------------------------------------     
//                      * Synchronous, 1-Port SRAM *                  
//                      * Verilog Behavioral Model *                  
//                THIS IS A SYNCHRONOUS 1-PORT MEMORY MODEL           
//                                                                    
//   Memory Name:ram4kx32_1p1r1w_bw                                   
//   Memory Size:4096 words x 32 bits                                 
//                                                                    
//                               PORT NAME                            
//                               ---------                            
//               Output Ports                                         
//                                   Q[31:0]                          
//               Input Ports:                                         
//                                   ADR[11:0]                        
//                                   D[31:0]                          
//                                   WEM[31:0]                        
//                                   WE                               
//                                   ME                               
//                                   CLK                              
//                                   TEST1                            
//                                   RME                              
//                                   RM[3:0]                          
// -------------------------------------------------------------------- 

`resetall 
`timescale 1 ns / 1 ps 
`celldefine 
`ifdef verifault // for fault simulation purpose 
`suppress_faults 
`enable_portfaults 
`endif 

`define True    1'b1
`define False   1'b0

module ram4kx32_1p1r1w_bw ( Q, ADR, D, WEM, WE, ME, CLK, TEST1, RME, RM);

// Input/Output Ports Declaration
input WE; // Memory Write Enable Input 
input ME; // Memory Enable Input 
input CLK; // Clock Input 
input TEST1; // Test1 Input 
input RME; // Read Margin Enable Input 
input  [11:0] ADR; // Address Input 
input  [31:0] D; // Data Input 
input  [31:0] WEM; // Maskable Write Enable 
input  [3:0] RM; // Read Margin Input 
output  [31:0] Q; // Data Output Bus


// Local registers, wires, etc
parameter PreloadFilename = "init.file";
`ifdef MEM_CHECK_OFF
parameter MES_ALL = "OFF";
`else
parameter MES_ALL = "ON";
`endif

`ifdef VIRAGE_FAST_VERILOG
`else
// Notifiers Declaration
reg notif_adr;
reg notif_d;
reg notif_wem;
reg notif_we;
reg notif_me;
reg notif_clk;
reg notif_test1;
reg notif_rme;
reg notif_rm;
`endif
reg ADRFLAGA;
reg TADRFLAGA;
reg  [11 : 0 ] ADR_old;
reg  ME_old;
reg  WE_old;
reg  [31 : 0 ] WEMbus_old;
`ifdef VIRAGE_FAST_VERILOG
wire [31:0] Q_buf;
assign Q[0] = Q_buf[0];
assign Q[1] = Q_buf[1];
assign Q[2] = Q_buf[2];
assign Q[3] = Q_buf[3];
assign Q[4] = Q_buf[4];
assign Q[5] = Q_buf[5];
assign Q[6] = Q_buf[6];
assign Q[7] = Q_buf[7];
assign Q[8] = Q_buf[8];
assign Q[9] = Q_buf[9];
assign Q[10] = Q_buf[10];
assign Q[11] = Q_buf[11];
assign Q[12] = Q_buf[12];
assign Q[13] = Q_buf[13];
assign Q[14] = Q_buf[14];
assign Q[15] = Q_buf[15];
assign Q[16] = Q_buf[16];
assign Q[17] = Q_buf[17];
assign Q[18] = Q_buf[18];
assign Q[19] = Q_buf[19];
assign Q[20] = Q_buf[20];
assign Q[21] = Q_buf[21];
assign Q[22] = Q_buf[22];
assign Q[23] = Q_buf[23];
assign Q[24] = Q_buf[24];
assign Q[25] = Q_buf[25];
assign Q[26] = Q_buf[26];
assign Q[27] = Q_buf[27];
assign Q[28] = Q_buf[28];
assign Q[29] = Q_buf[29];
assign Q[30] = Q_buf[30];
assign Q[31] = Q_buf[31];
wire [11:0] ADR_buf;
assign  ADR_buf[0] =  ADR[0];
assign  ADR_buf[1] =  ADR[1];
assign  ADR_buf[2] =  ADR[2];
assign  ADR_buf[3] =  ADR[3];
assign  ADR_buf[4] =  ADR[4];
assign  ADR_buf[5] =  ADR[5];
assign  ADR_buf[6] =  ADR[6];
assign  ADR_buf[7] =  ADR[7];
assign  ADR_buf[8] =  ADR[8];
assign  ADR_buf[9] =  ADR[9];
assign  ADR_buf[10] =  ADR[10];
assign  ADR_buf[11] =  ADR[11];
wire [31:0] D_buf;
assign  D_buf[0] =  D[0];
assign  D_buf[1] =  D[1];
assign  D_buf[2] =  D[2];
assign  D_buf[3] =  D[3];
assign  D_buf[4] =  D[4];
assign  D_buf[5] =  D[5];
assign  D_buf[6] =  D[6];
assign  D_buf[7] =  D[7];
assign  D_buf[8] =  D[8];
assign  D_buf[9] =  D[9];
assign  D_buf[10] =  D[10];
assign  D_buf[11] =  D[11];
assign  D_buf[12] =  D[12];
assign  D_buf[13] =  D[13];
assign  D_buf[14] =  D[14];
assign  D_buf[15] =  D[15];
assign  D_buf[16] =  D[16];
assign  D_buf[17] =  D[17];
assign  D_buf[18] =  D[18];
assign  D_buf[19] =  D[19];
assign  D_buf[20] =  D[20];
assign  D_buf[21] =  D[21];
assign  D_buf[22] =  D[22];
assign  D_buf[23] =  D[23];
assign  D_buf[24] =  D[24];
assign  D_buf[25] =  D[25];
assign  D_buf[26] =  D[26];
assign  D_buf[27] =  D[27];
assign  D_buf[28] =  D[28];
assign  D_buf[29] =  D[29];
assign  D_buf[30] =  D[30];
assign  D_buf[31] =  D[31];
wire [31:0] WEM_buf;
assign  WEM_buf[0] =  WEM[0];
assign  WEM_buf[1] =  WEM[1];
assign  WEM_buf[2] =  WEM[2];
assign  WEM_buf[3] =  WEM[3];
assign  WEM_buf[4] =  WEM[4];
assign  WEM_buf[5] =  WEM[5];
assign  WEM_buf[6] =  WEM[6];
assign  WEM_buf[7] =  WEM[7];
assign  WEM_buf[8] =  WEM[8];
assign  WEM_buf[9] =  WEM[9];
assign  WEM_buf[10] =  WEM[10];
assign  WEM_buf[11] =  WEM[11];
assign  WEM_buf[12] =  WEM[12];
assign  WEM_buf[13] =  WEM[13];
assign  WEM_buf[14] =  WEM[14];
assign  WEM_buf[15] =  WEM[15];
assign  WEM_buf[16] =  WEM[16];
assign  WEM_buf[17] =  WEM[17];
assign  WEM_buf[18] =  WEM[18];
assign  WEM_buf[19] =  WEM[19];
assign  WEM_buf[20] =  WEM[20];
assign  WEM_buf[21] =  WEM[21];
assign  WEM_buf[22] =  WEM[22];
assign  WEM_buf[23] =  WEM[23];
assign  WEM_buf[24] =  WEM[24];
assign  WEM_buf[25] =  WEM[25];
assign  WEM_buf[26] =  WEM[26];
assign  WEM_buf[27] =  WEM[27];
assign  WEM_buf[28] =  WEM[28];
assign  WEM_buf[29] =  WEM[29];
assign  WEM_buf[30] =  WEM[30];
assign  WEM_buf[31] =  WEM[31];
wire WE_buf;
assign  WE_buf =  WE;
wire ME_buf;
assign  ME_buf =  ME;
wire CLK_buf;
assign  CLK_buf =  CLK;
wire TEST1_buf;
assign  TEST1_buf =  TEST1;
wire RME_buf;
assign  RME_buf =  RME;
wire [3:0] RM_int;
wire [3:0] RM_buf;
assign  RM_buf[0] =  RM[0];
assign  RM_buf[1] =  RM[1];
assign  RM_buf[2] =  RM[2];
assign  RM_buf[3] =  RM[3];
`else
wire [31:0] Q_buf;
buf (Q[0], Q_buf[0]);
buf (Q[1], Q_buf[1]);
buf (Q[2], Q_buf[2]);
buf (Q[3], Q_buf[3]);
buf (Q[4], Q_buf[4]);
buf (Q[5], Q_buf[5]);
buf (Q[6], Q_buf[6]);
buf (Q[7], Q_buf[7]);
buf (Q[8], Q_buf[8]);
buf (Q[9], Q_buf[9]);
buf (Q[10], Q_buf[10]);
buf (Q[11], Q_buf[11]);
buf (Q[12], Q_buf[12]);
buf (Q[13], Q_buf[13]);
buf (Q[14], Q_buf[14]);
buf (Q[15], Q_buf[15]);
buf (Q[16], Q_buf[16]);
buf (Q[17], Q_buf[17]);
buf (Q[18], Q_buf[18]);
buf (Q[19], Q_buf[19]);
buf (Q[20], Q_buf[20]);
buf (Q[21], Q_buf[21]);
buf (Q[22], Q_buf[22]);
buf (Q[23], Q_buf[23]);
buf (Q[24], Q_buf[24]);
buf (Q[25], Q_buf[25]);
buf (Q[26], Q_buf[26]);
buf (Q[27], Q_buf[27]);
buf (Q[28], Q_buf[28]);
buf (Q[29], Q_buf[29]);
buf (Q[30], Q_buf[30]);
buf (Q[31], Q_buf[31]);
wire [11:0] ADR_buf;
buf (ADR_buf[0], ADR[0]);
buf (ADR_buf[1], ADR[1]);
buf (ADR_buf[2], ADR[2]);
buf (ADR_buf[3], ADR[3]);
buf (ADR_buf[4], ADR[4]);
buf (ADR_buf[5], ADR[5]);
buf (ADR_buf[6], ADR[6]);
buf (ADR_buf[7], ADR[7]);
buf (ADR_buf[8], ADR[8]);
buf (ADR_buf[9], ADR[9]);
buf (ADR_buf[10], ADR[10]);
buf (ADR_buf[11], ADR[11]);
wire [31:0] D_buf;
buf (D_buf[0], D[0]);
buf (D_buf[1], D[1]);
buf (D_buf[2], D[2]);
buf (D_buf[3], D[3]);
buf (D_buf[4], D[4]);
buf (D_buf[5], D[5]);
buf (D_buf[6], D[6]);
buf (D_buf[7], D[7]);
buf (D_buf[8], D[8]);
buf (D_buf[9], D[9]);
buf (D_buf[10], D[10]);
buf (D_buf[11], D[11]);
buf (D_buf[12], D[12]);
buf (D_buf[13], D[13]);
buf (D_buf[14], D[14]);
buf (D_buf[15], D[15]);
buf (D_buf[16], D[16]);
buf (D_buf[17], D[17]);
buf (D_buf[18], D[18]);
buf (D_buf[19], D[19]);
buf (D_buf[20], D[20]);
buf (D_buf[21], D[21]);
buf (D_buf[22], D[22]);
buf (D_buf[23], D[23]);
buf (D_buf[24], D[24]);
buf (D_buf[25], D[25]);
buf (D_buf[26], D[26]);
buf (D_buf[27], D[27]);
buf (D_buf[28], D[28]);
buf (D_buf[29], D[29]);
buf (D_buf[30], D[30]);
buf (D_buf[31], D[31]);
wire [31:0] WEM_buf;
buf (WEM_buf[0], WEM[0]);
buf (WEM_buf[1], WEM[1]);
buf (WEM_buf[2], WEM[2]);
buf (WEM_buf[3], WEM[3]);
buf (WEM_buf[4], WEM[4]);
buf (WEM_buf[5], WEM[5]);
buf (WEM_buf[6], WEM[6]);
buf (WEM_buf[7], WEM[7]);
buf (WEM_buf[8], WEM[8]);
buf (WEM_buf[9], WEM[9]);
buf (WEM_buf[10], WEM[10]);
buf (WEM_buf[11], WEM[11]);
buf (WEM_buf[12], WEM[12]);
buf (WEM_buf[13], WEM[13]);
buf (WEM_buf[14], WEM[14]);
buf (WEM_buf[15], WEM[15]);
buf (WEM_buf[16], WEM[16]);
buf (WEM_buf[17], WEM[17]);
buf (WEM_buf[18], WEM[18]);
buf (WEM_buf[19], WEM[19]);
buf (WEM_buf[20], WEM[20]);
buf (WEM_buf[21], WEM[21]);
buf (WEM_buf[22], WEM[22]);
buf (WEM_buf[23], WEM[23]);
buf (WEM_buf[24], WEM[24]);
buf (WEM_buf[25], WEM[25]);
buf (WEM_buf[26], WEM[26]);
buf (WEM_buf[27], WEM[27]);
buf (WEM_buf[28], WEM[28]);
buf (WEM_buf[29], WEM[29]);
buf (WEM_buf[30], WEM[30]);
buf (WEM_buf[31], WEM[31]);
buf (WE_buf, WE);
buf (ME_buf, ME);
buf (CLK_buf, CLK);
buf (TEST1_buf, TEST1);
buf (RME_buf, RME);
wire [3:0] RM_int;
wire [3:0] RM_buf;
buf (RM_buf[0], RM[0]);
buf (RM_buf[1], RM[1]);
buf (RM_buf[2], RM[2]);
buf (RM_buf[3], RM[3]);
`endif
wire ADR_valid;
//assign ADR_valid =  (ADR_buf >= 12'b000000000000 && ADR_buf <= 12'b111111111111 )?1'b1:1'b0;
assign ADR_valid =  (ADR_buf <= 12'b111111111111 )?1'b1:1'b0;
// Setup/hold conditions for syncronous signals
`ifdef VIRAGE_FAST_VERILOG
`else
reg  ME_pre,WE_pre;
reg  [31:0] WEM_pre;

always @(ME_buf or negedge CLK_buf) 
begin : blk_mebuf_0
  if ( CLK_buf == 1'b0)
  begin
    ME_pre = ME_buf;
  end // if of CLK_buf = 0
end // end of always block blk_mebuf_0

always @(WE_buf or negedge CLK_buf) 
begin : blk_webuf_0
  if ( CLK_buf == 1'b0)
  begin
    WE_pre = WE_buf;
  end // if of CLK_buf = 0
end // end of always block blk_webuf_0

always @(WEM_buf or negedge CLK_buf)
begin : blk_wembuf_0
  if ( CLK_buf == 1'b0)
  begin
    WEM_pre = WEM_buf;
  end // if of CLK_buf = 0
end // end of always block blk_wembuf_$
// Setup/hold condition for Address: ADR is : ENADR
wire ENADR;
buf ( ENADR, ME_pre );
 
// Setup/hold condition for Memory Enable: ME is : ENME
wire ENME;
buf ( ENME, ADR_valid );

// Setup/hold condition for Write Enable: WE is : ENWE
wire ENWE;
assign ENWE = (( ADR_valid && ME_pre !== 1'b0 ) ?1'b1:1'b0);

// Setup/hold condition for Write Enable Mask: WEM is : ENWEM
wire ENWEM;
assign ENWEM =  (( ADR_valid && ME_pre !== 1'b0 && WE_pre !== 1'b0 )?1'b1:1'b0);

// Setup/hold condition for Data In: D is : END
wire END;
assign END = (( ADR_valid && ME_pre !== 1'b0 && WE_pre !== 1'b0 && (|WEM_pre) !== 1'b0 )?1'b1:1'b0) ;

// Setup/hold condition for test1 Vector: TEST1 is : ENTEST1
wire ENTEST1;
assign ENTEST1 = ((ME_pre !== 1'b0 && ADR_valid)?1'b1:1'b0);
 
// Setup/hold condition for Read Margin Vector: RM is : ENRM
wire ENRM;
assign ENRM = ((RME_buf === 1'b1 && (ME_pre !== 1'b0 && ADR_valid))?1'b1:1'b0);
// Setup/hold condition for Read Margin Vector Enable: RME is : ENRME
wire ENRME;
assign ENRME = ((ME_pre !== 1'b0 && ADR_valid)?1'b1:1'b0);
wire ENCLK_rmezo,ENCLK_vdm,ENCLK_slw,ENCLK_def,ENCLK_fst;
assign ENCLK_rmezo = ((RME_buf !== 1'b1)?1'b1:1'b0) ;
assign ENCLK_vdm = ((RME_buf === 1'b1  && ( (!RM_buf[0]) && (!RM_buf[1]) && (!RM_buf[2]) && (!RM_buf[3]) ))?1'b1:1'b0) ;
assign ENCLK_slw = ((RME_buf === 1'b1  && ( (RM_buf[0]) && (!RM_buf[1]) && (!RM_buf[2]) && (!RM_buf[3]) ))?1'b1:1'b0) ;
assign ENCLK_def = ((RME_buf === 1'b1  && ( (!RM_buf[0]) && (RM_buf[1]) && (!RM_buf[2]) && (!RM_buf[3]) ))?1'b1:1'b0) ;
assign ENCLK_fst = ((RME_buf === 1'b1  && ( (RM_buf[0]) && (RM_buf[1]) && (!RM_buf[2]) && (!RM_buf[3]) ))?1'b1:1'b0) ;
`endif // endif of VIRAGE_FAST_VERILOG
reg ME_buf_L;
reg WE_buf_L;
wire WEM_active;
wire WEM_active_eff;
wire [31:0] WEMbus_eff;
wire [31:0] WEMbus;
`ifdef VIRAGE_FAST_VERILOG
`else
assign WEMbus = { WEM_buf };
assign WEM_active = ((|(WEMbus)===0)?1'b0:1'b1);
assign WEM_active_eff = WEM_active;
`endif // endif of VIRAGE_FAST_VERILOG

`ifdef VIRAGE_FAST_VERILOG
`else
specify
 
  specparam
    Tac = 0.438,
    Tcax = 0.077,
    Tdc = 0.238,
    Tcdx = 0.078,
    Twmc = 0.238,
    Tcwmx = 0.078,
    Twc = 0.394,
    Tcwx = 0.055,
    Tmc = 0.883,
    Tcmx = 0.000,
    Tcl = 0.222,
    Tch = 0.200,
    Tcc = 1.638,
    Tccvddmin = 3.164,
    Tccslow = 2.299,
    Tccdef = 1.638,
    Tccfast = 1.620,
    TT1C = 0.000,
    TCT1X = 0.768,
    Trmec = 0.465,
    Tcrmex = 0.409,
    Trmc = 0.441,
    Tcrmx = 0.401,
    Tcq = 1.228,
    Tcqx = 1.185,
    Tcqvddmin = 2.634,
    Tcqvddminx = 2.577,
    Tcqslow = 1.806,
    Tcqslowx = 1.758,
    Tcqdef = 1.228,
    Tcqdefx = 1.185,
    Tcqfast = 1.107,
    Tcqfastx = 1.064;
     if (   !RME )
       ( posedge CLK => (  Q[31]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RME )
       ( posedge CLK => (  Q[30]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RME )
       ( posedge CLK => (  Q[29]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RME )
       ( posedge CLK => (  Q[28]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RME )
       ( posedge CLK => (  Q[27]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RME )
       ( posedge CLK => (  Q[26]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RME )
       ( posedge CLK => (  Q[25]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RME )
       ( posedge CLK => (  Q[24]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RME )
       ( posedge CLK => (  Q[23]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RME )
       ( posedge CLK => (  Q[22]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RME )
       ( posedge CLK => (  Q[21]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RME )
       ( posedge CLK => (  Q[20]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RME )
       ( posedge CLK => (  Q[19]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RME )
       ( posedge CLK => (  Q[18]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RME )
       ( posedge CLK => (  Q[17]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RME )
       ( posedge CLK => (  Q[16]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RME )
       ( posedge CLK => (  Q[15]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RME )
       ( posedge CLK => (  Q[14]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RME )
       ( posedge CLK => (  Q[13]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RME )
       ( posedge CLK => (  Q[12]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RME )
       ( posedge CLK => (  Q[11]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RME )
       ( posedge CLK => (  Q[10]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RME )
       ( posedge CLK => (  Q[9]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RME )
       ( posedge CLK => (  Q[8]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RME )
       ( posedge CLK => (  Q[7]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RME )
       ( posedge CLK => (  Q[6]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RME )
       ( posedge CLK => (  Q[5]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RME )
       ( posedge CLK => (  Q[4]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RME )
       ( posedge CLK => (  Q[3]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RME )
       ( posedge CLK => (  Q[2]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RME )
       ( posedge CLK => (  Q[1]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   !RME )
       ( posedge CLK => (  Q[0]  : 1'bx )) = (  Tcq, Tcq, Tcqx, Tcq, Tcqx, Tcq );
     if (   RME &  !RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[31]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RME &  !RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[30]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RME &  !RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[29]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RME &  !RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[28]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RME &  !RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[27]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RME &  !RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[26]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RME &  !RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[25]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RME &  !RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[24]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RME &  !RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[23]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RME &  !RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[22]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RME &  !RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[21]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RME &  !RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[20]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RME &  !RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[19]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RME &  !RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[18]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RME &  !RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[17]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RME &  !RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[16]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RME &  !RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[15]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RME &  !RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[14]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RME &  !RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[13]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RME &  !RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[12]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RME &  !RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[11]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RME &  !RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[10]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RME &  !RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[9]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RME &  !RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[8]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RME &  !RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[7]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RME &  !RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[6]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RME &  !RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[5]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RME &  !RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[4]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RME &  !RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[3]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RME &  !RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[2]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RME &  !RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[1]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RME &  !RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[0]  : 1'bx )) = (  Tcqvddmin, Tcqvddmin, Tcqvddminx, Tcqvddmin, Tcqvddminx, Tcqvddmin );
     if (   RME &  RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[31]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RME &  RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[30]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RME &  RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[29]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RME &  RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[28]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RME &  RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[27]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RME &  RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[26]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RME &  RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[25]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RME &  RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[24]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RME &  RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[23]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RME &  RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[22]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RME &  RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[21]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RME &  RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[20]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RME &  RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[19]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RME &  RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[18]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RME &  RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[17]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RME &  RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[16]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RME &  RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[15]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RME &  RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[14]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RME &  RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[13]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RME &  RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[12]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RME &  RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[11]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RME &  RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[10]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RME &  RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[9]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RME &  RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[8]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RME &  RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[7]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RME &  RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[6]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RME &  RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[5]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RME &  RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[4]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RME &  RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[3]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RME &  RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[2]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RME &  RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[1]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RME &  RM[0] & !RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[0]  : 1'bx )) = (  Tcqslow, Tcqslow, Tcqslowx, Tcqslow, Tcqslowx, Tcqslow );
     if (   RME &  !RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[31]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RME &  !RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[30]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RME &  !RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[29]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RME &  !RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[28]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RME &  !RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[27]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RME &  !RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[26]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RME &  !RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[25]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RME &  !RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[24]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RME &  !RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[23]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RME &  !RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[22]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RME &  !RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[21]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RME &  !RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[20]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RME &  !RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[19]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RME &  !RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[18]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RME &  !RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[17]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RME &  !RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[16]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RME &  !RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[15]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RME &  !RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[14]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RME &  !RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[13]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RME &  !RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[12]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RME &  !RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[11]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RME &  !RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[10]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RME &  !RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[9]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RME &  !RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[8]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RME &  !RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[7]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RME &  !RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[6]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RME &  !RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[5]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RME &  !RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[4]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RME &  !RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[3]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RME &  !RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[2]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RME &  !RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[1]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RME &  !RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[0]  : 1'bx )) = (  Tcqdef, Tcqdef, Tcqdefx, Tcqdef, Tcqdefx, Tcqdef );
     if (   RME &  RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[31]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RME &  RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[30]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RME &  RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[29]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RME &  RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[28]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RME &  RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[27]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RME &  RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[26]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RME &  RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[25]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RME &  RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[24]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RME &  RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[23]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RME &  RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[22]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RME &  RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[21]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RME &  RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[20]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RME &  RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[19]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RME &  RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[18]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RME &  RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[17]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RME &  RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[16]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RME &  RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[15]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RME &  RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[14]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RME &  RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[13]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RME &  RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[12]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RME &  RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[11]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RME &  RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[10]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RME &  RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[9]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RME &  RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[8]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RME &  RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[7]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RME &  RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[6]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RME &  RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[5]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RME &  RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[4]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RME &  RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[3]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RME &  RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[2]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RME &  RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[1]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );
     if (   RME &  RM[0] & RM[1] & !RM[2] & !RM[3]  )
       ( posedge CLK => (  Q[0]  : 1'bx )) = (  Tcqfast, Tcqfast, Tcqfastx, Tcqfast, Tcqfastx, Tcqfast );

// Timing Checks

  $width (negedge CLK, Tcl, 0, notif_clk);
  $width (posedge CLK, Tch, 0, notif_clk);
  $period (posedge CLK &&& ENCLK_rmezo, Tcc, notif_clk);
  $period (negedge CLK &&& ENCLK_rmezo, Tcc, notif_clk);
  $period (posedge CLK &&& ENCLK_vdm, Tccvddmin, notif_clk);
  $period (negedge CLK &&& ENCLK_vdm, Tccvddmin, notif_clk);
  $period (posedge CLK &&& ENCLK_slw, Tccslow, notif_clk);
  $period (negedge CLK &&& ENCLK_slw, Tccslow, notif_clk);
  $period (posedge CLK &&& ENCLK_def, Tccdef, notif_clk);
  $period (negedge CLK &&& ENCLK_def, Tccdef, notif_clk);
  $period (posedge CLK &&& ENCLK_fst, Tccfast, notif_clk);
  $period (negedge CLK &&& ENCLK_fst, Tccfast, notif_clk);
  $setuphold (posedge CLK  &&& ENADR, posedge ADR[0], Tac, Tcax, notif_adr );
  $setuphold (posedge CLK  &&& ENADR, negedge ADR[0], Tac, Tcax, notif_adr );
  $setuphold (posedge CLK  &&& ENADR, posedge ADR[1], Tac, Tcax, notif_adr );
  $setuphold (posedge CLK  &&& ENADR, negedge ADR[1], Tac, Tcax, notif_adr );
  $setuphold (posedge CLK  &&& ENADR, posedge ADR[2], Tac, Tcax, notif_adr );
  $setuphold (posedge CLK  &&& ENADR, negedge ADR[2], Tac, Tcax, notif_adr );
  $setuphold (posedge CLK  &&& ENADR, posedge ADR[3], Tac, Tcax, notif_adr );
  $setuphold (posedge CLK  &&& ENADR, negedge ADR[3], Tac, Tcax, notif_adr );
  $setuphold (posedge CLK  &&& ENADR, posedge ADR[4], Tac, Tcax, notif_adr );
  $setuphold (posedge CLK  &&& ENADR, negedge ADR[4], Tac, Tcax, notif_adr );
  $setuphold (posedge CLK  &&& ENADR, posedge ADR[5], Tac, Tcax, notif_adr );
  $setuphold (posedge CLK  &&& ENADR, negedge ADR[5], Tac, Tcax, notif_adr );
  $setuphold (posedge CLK  &&& ENADR, posedge ADR[6], Tac, Tcax, notif_adr );
  $setuphold (posedge CLK  &&& ENADR, negedge ADR[6], Tac, Tcax, notif_adr );
  $setuphold (posedge CLK  &&& ENADR, posedge ADR[7], Tac, Tcax, notif_adr );
  $setuphold (posedge CLK  &&& ENADR, negedge ADR[7], Tac, Tcax, notif_adr );
  $setuphold (posedge CLK  &&& ENADR, posedge ADR[8], Tac, Tcax, notif_adr );
  $setuphold (posedge CLK  &&& ENADR, negedge ADR[8], Tac, Tcax, notif_adr );
  $setuphold (posedge CLK  &&& ENADR, posedge ADR[9], Tac, Tcax, notif_adr );
  $setuphold (posedge CLK  &&& ENADR, negedge ADR[9], Tac, Tcax, notif_adr );
  $setuphold (posedge CLK  &&& ENADR, posedge ADR[10], Tac, Tcax, notif_adr );
  $setuphold (posedge CLK  &&& ENADR, negedge ADR[10], Tac, Tcax, notif_adr );
  $setuphold (posedge CLK  &&& ENADR, posedge ADR[11], Tac, Tcax, notif_adr );
  $setuphold (posedge CLK  &&& ENADR, negedge ADR[11], Tac, Tcax, notif_adr );
  $setuphold (posedge CLK  &&& END, posedge D[0], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, negedge D[0], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, posedge D[1], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, negedge D[1], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, posedge D[2], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, negedge D[2], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, posedge D[3], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, negedge D[3], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, posedge D[4], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, negedge D[4], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, posedge D[5], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, negedge D[5], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, posedge D[6], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, negedge D[6], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, posedge D[7], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, negedge D[7], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, posedge D[8], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, negedge D[8], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, posedge D[9], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, negedge D[9], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, posedge D[10], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, negedge D[10], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, posedge D[11], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, negedge D[11], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, posedge D[12], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, negedge D[12], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, posedge D[13], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, negedge D[13], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, posedge D[14], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, negedge D[14], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, posedge D[15], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, negedge D[15], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, posedge D[16], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, negedge D[16], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, posedge D[17], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, negedge D[17], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, posedge D[18], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, negedge D[18], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, posedge D[19], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, negedge D[19], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, posedge D[20], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, negedge D[20], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, posedge D[21], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, negedge D[21], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, posedge D[22], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, negedge D[22], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, posedge D[23], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, negedge D[23], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, posedge D[24], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, negedge D[24], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, posedge D[25], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, negedge D[25], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, posedge D[26], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, negedge D[26], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, posedge D[27], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, negedge D[27], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, posedge D[28], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, negedge D[28], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, posedge D[29], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, negedge D[29], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, posedge D[30], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, negedge D[30], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, posedge D[31], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& END, negedge D[31], Tdc, Tcdx, notif_d );
  $setuphold (posedge CLK  &&& ENWEM, posedge WEM[0], Twmc, Tcwmx, notif_wem );
  $setuphold (posedge CLK  &&& ENWEM, negedge WEM[0], Twmc, Tcwmx, notif_wem );
  $setuphold (posedge CLK  &&& ENWEM, posedge WEM[1], Twmc, Tcwmx, notif_wem );
  $setuphold (posedge CLK  &&& ENWEM, negedge WEM[1], Twmc, Tcwmx, notif_wem );
  $setuphold (posedge CLK  &&& ENWEM, posedge WEM[2], Twmc, Tcwmx, notif_wem );
  $setuphold (posedge CLK  &&& ENWEM, negedge WEM[2], Twmc, Tcwmx, notif_wem );
  $setuphold (posedge CLK  &&& ENWEM, posedge WEM[3], Twmc, Tcwmx, notif_wem );
  $setuphold (posedge CLK  &&& ENWEM, negedge WEM[3], Twmc, Tcwmx, notif_wem );
  $setuphold (posedge CLK  &&& ENWEM, posedge WEM[4], Twmc, Tcwmx, notif_wem );
  $setuphold (posedge CLK  &&& ENWEM, negedge WEM[4], Twmc, Tcwmx, notif_wem );
  $setuphold (posedge CLK  &&& ENWEM, posedge WEM[5], Twmc, Tcwmx, notif_wem );
  $setuphold (posedge CLK  &&& ENWEM, negedge WEM[5], Twmc, Tcwmx, notif_wem );
  $setuphold (posedge CLK  &&& ENWEM, posedge WEM[6], Twmc, Tcwmx, notif_wem );
  $setuphold (posedge CLK  &&& ENWEM, negedge WEM[6], Twmc, Tcwmx, notif_wem );
  $setuphold (posedge CLK  &&& ENWEM, posedge WEM[7], Twmc, Tcwmx, notif_wem );
  $setuphold (posedge CLK  &&& ENWEM, negedge WEM[7], Twmc, Tcwmx, notif_wem );
  $setuphold (posedge CLK  &&& ENWEM, posedge WEM[8], Twmc, Tcwmx, notif_wem );
  $setuphold (posedge CLK  &&& ENWEM, negedge WEM[8], Twmc, Tcwmx, notif_wem );
  $setuphold (posedge CLK  &&& ENWEM, posedge WEM[9], Twmc, Tcwmx, notif_wem );
  $setuphold (posedge CLK  &&& ENWEM, negedge WEM[9], Twmc, Tcwmx, notif_wem );
  $setuphold (posedge CLK  &&& ENWEM, posedge WEM[10], Twmc, Tcwmx, notif_wem );
  $setuphold (posedge CLK  &&& ENWEM, negedge WEM[10], Twmc, Tcwmx, notif_wem );
  $setuphold (posedge CLK  &&& ENWEM, posedge WEM[11], Twmc, Tcwmx, notif_wem );
  $setuphold (posedge CLK  &&& ENWEM, negedge WEM[11], Twmc, Tcwmx, notif_wem );
  $setuphold (posedge CLK  &&& ENWEM, posedge WEM[12], Twmc, Tcwmx, notif_wem );
  $setuphold (posedge CLK  &&& ENWEM, negedge WEM[12], Twmc, Tcwmx, notif_wem );
  $setuphold (posedge CLK  &&& ENWEM, posedge WEM[13], Twmc, Tcwmx, notif_wem );
  $setuphold (posedge CLK  &&& ENWEM, negedge WEM[13], Twmc, Tcwmx, notif_wem );
  $setuphold (posedge CLK  &&& ENWEM, posedge WEM[14], Twmc, Tcwmx, notif_wem );
  $setuphold (posedge CLK  &&& ENWEM, negedge WEM[14], Twmc, Tcwmx, notif_wem );
  $setuphold (posedge CLK  &&& ENWEM, posedge WEM[15], Twmc, Tcwmx, notif_wem );
  $setuphold (posedge CLK  &&& ENWEM, negedge WEM[15], Twmc, Tcwmx, notif_wem );
  $setuphold (posedge CLK  &&& ENWEM, posedge WEM[16], Twmc, Tcwmx, notif_wem );
  $setuphold (posedge CLK  &&& ENWEM, negedge WEM[16], Twmc, Tcwmx, notif_wem );
  $setuphold (posedge CLK  &&& ENWEM, posedge WEM[17], Twmc, Tcwmx, notif_wem );
  $setuphold (posedge CLK  &&& ENWEM, negedge WEM[17], Twmc, Tcwmx, notif_wem );
  $setuphold (posedge CLK  &&& ENWEM, posedge WEM[18], Twmc, Tcwmx, notif_wem );
  $setuphold (posedge CLK  &&& ENWEM, negedge WEM[18], Twmc, Tcwmx, notif_wem );
  $setuphold (posedge CLK  &&& ENWEM, posedge WEM[19], Twmc, Tcwmx, notif_wem );
  $setuphold (posedge CLK  &&& ENWEM, negedge WEM[19], Twmc, Tcwmx, notif_wem );
  $setuphold (posedge CLK  &&& ENWEM, posedge WEM[20], Twmc, Tcwmx, notif_wem );
  $setuphold (posedge CLK  &&& ENWEM, negedge WEM[20], Twmc, Tcwmx, notif_wem );
  $setuphold (posedge CLK  &&& ENWEM, posedge WEM[21], Twmc, Tcwmx, notif_wem );
  $setuphold (posedge CLK  &&& ENWEM, negedge WEM[21], Twmc, Tcwmx, notif_wem );
  $setuphold (posedge CLK  &&& ENWEM, posedge WEM[22], Twmc, Tcwmx, notif_wem );
  $setuphold (posedge CLK  &&& ENWEM, negedge WEM[22], Twmc, Tcwmx, notif_wem );
  $setuphold (posedge CLK  &&& ENWEM, posedge WEM[23], Twmc, Tcwmx, notif_wem );
  $setuphold (posedge CLK  &&& ENWEM, negedge WEM[23], Twmc, Tcwmx, notif_wem );
  $setuphold (posedge CLK  &&& ENWEM, posedge WEM[24], Twmc, Tcwmx, notif_wem );
  $setuphold (posedge CLK  &&& ENWEM, negedge WEM[24], Twmc, Tcwmx, notif_wem );
  $setuphold (posedge CLK  &&& ENWEM, posedge WEM[25], Twmc, Tcwmx, notif_wem );
  $setuphold (posedge CLK  &&& ENWEM, negedge WEM[25], Twmc, Tcwmx, notif_wem );
  $setuphold (posedge CLK  &&& ENWEM, posedge WEM[26], Twmc, Tcwmx, notif_wem );
  $setuphold (posedge CLK  &&& ENWEM, negedge WEM[26], Twmc, Tcwmx, notif_wem );
  $setuphold (posedge CLK  &&& ENWEM, posedge WEM[27], Twmc, Tcwmx, notif_wem );
  $setuphold (posedge CLK  &&& ENWEM, negedge WEM[27], Twmc, Tcwmx, notif_wem );
  $setuphold (posedge CLK  &&& ENWEM, posedge WEM[28], Twmc, Tcwmx, notif_wem );
  $setuphold (posedge CLK  &&& ENWEM, negedge WEM[28], Twmc, Tcwmx, notif_wem );
  $setuphold (posedge CLK  &&& ENWEM, posedge WEM[29], Twmc, Tcwmx, notif_wem );
  $setuphold (posedge CLK  &&& ENWEM, negedge WEM[29], Twmc, Tcwmx, notif_wem );
  $setuphold (posedge CLK  &&& ENWEM, posedge WEM[30], Twmc, Tcwmx, notif_wem );
  $setuphold (posedge CLK  &&& ENWEM, negedge WEM[30], Twmc, Tcwmx, notif_wem );
  $setuphold (posedge CLK  &&& ENWEM, posedge WEM[31], Twmc, Tcwmx, notif_wem );
  $setuphold (posedge CLK  &&& ENWEM, negedge WEM[31], Twmc, Tcwmx, notif_wem );
  $setuphold (posedge CLK  &&& ENWE, posedge WE,Twc, Tcwx, notif_we );
  $setuphold (posedge CLK  &&& ENWE, negedge WE,Twc, Tcwx, notif_we );
  $setuphold (posedge CLK  &&& ENME, posedge ME,Tmc, Tcmx, notif_me );
  $setuphold (posedge CLK  &&& ENME, negedge ME,Tmc, Tcmx, notif_me );
  $hold (negedge CLK  &&& ENTEST1, posedge TEST1, TCT1X, notif_test1 );
  $hold (negedge CLK  &&& ENTEST1, negedge TEST1, TCT1X, notif_test1 );
  $setup ( posedge TEST1,posedge CLK  &&& ENTEST1, TT1C, notif_test1 );
  $setup ( negedge TEST1,posedge CLK  &&& ENTEST1, TT1C, notif_test1 );
  $setuphold (posedge CLK  &&& ENRME, posedge RME,Trmec, Tcrmex, notif_rme );
  $setuphold (posedge CLK  &&& ENRME, negedge RME,Trmec, Tcrmex, notif_rme );
  $setuphold (posedge CLK  &&& ENRM, posedge RM[0], Trmc, Tcrmx, notif_rm );
  $setuphold (posedge CLK  &&& ENRM, negedge RM[0], Trmc, Tcrmx, notif_rm );
  $setuphold (posedge CLK  &&& ENRM, posedge RM[1], Trmc, Tcrmx, notif_rm );
  $setuphold (posedge CLK  &&& ENRM, negedge RM[1], Trmc, Tcrmx, notif_rm );
  $setuphold (posedge CLK  &&& ENRM, posedge RM[2], Trmc, Tcrmx, notif_rm );
  $setuphold (posedge CLK  &&& ENRM, negedge RM[2], Trmc, Tcrmx, notif_rm );
  $setuphold (posedge CLK  &&& ENRM, posedge RM[3], Trmc, Tcrmx, notif_rm );
  $setuphold (posedge CLK  &&& ENRM, negedge RM[3], Trmc, Tcrmx, notif_rm );

endspecify
`endif // endif of VIRAGE_FAST_VERILOG

`ifdef VIRAGE_FAST_VERILOG
generic_behav_ram4kx32_1p1r1w_bw #( PreloadFilename, MES_ALL) u0 (  .Q (Q_buf), .ADR (ADR_buf), .D (D_buf), .WEM (WEM_buf), .WE(WE_buf), .ME(ME_buf), .CLK(CLK_buf), .TEST1(TEST1_buf), .RME(RME_buf), .RM (RM_int) );
`else
generic_behav_ram4kx32_1p1r1w_bw #( PreloadFilename, MES_ALL) u0 (  .Q (Q_buf), .ADR (ADR_buf), .D (D_buf), .WEM (WEM_buf), .WE(WE_buf), .ME(ME_buf), .CLK(CLK_buf), .TEST1(TEST1_buf), .RME(RME_buf), .RM (RM_int),.notif_adr(notif_adr), .notif_d(notif_d), .notif_wem(notif_wem), .notif_we(notif_we), .notif_me(notif_me), .notif_clk(notif_clk), .notif_test1(notif_test1), .notif_rme(notif_rme), .notif_rm(notif_rm) );
`endif // endif of VIRAGE_FAST_VERILOG

initial
begin
  ADRFLAGA = 1;
end // end of initial block
always @( ADR_buf or negedge CLK_buf)
begin : blk_adrzerohold_0
  if ( CLK_buf == 1'b0)
    ADR_old = ADR_buf;
end // end of always block blk_adrzerohold_0

always @( ME_buf or negedge CLK_buf)
begin : blk_mezerohold_0
  if ( CLK_buf == 1'b0)
    ME_old = ME_buf;
end

always @( WE_buf or negedge CLK_buf)
begin : blk_wezerohol_0
  if ( CLK_buf == 1'b0)
    WE_old = WE_buf;
end
always @( WEM_buf or negedge CLK_buf)
begin : blk_wemzerohold_0
  if ( CLK_buf == 1'b0)
  WEMbus_old = WEM_buf;
end
always @( posedge CLK_buf)
begin : blk_posclock_0
  ME_buf_L = ME_old;
  WE_buf_L = WE_old;
end

always @ ( ADR_buf )
begin : blk_address_0
  if ( $realtime != 0)
  begin
    if ( ADR_buf > 12'b111111111111) 
    begin
      ADRFLAGA = 0;
    end // if of address is out of range
    else
    begin
      ADRFLAGA = 1;
    end // else of if address is out of range
  end // if of $realtime != 0
end // end of always block blk_address_0

assign RM_int = ((RME_buf===1'b1)?RM_buf:((RME_buf===1'b0)?4'b0010:4'bx));
always @(posedge CLK_buf )
begin : blk_posclock1_0
  if(RME_buf === 1'bx && ME_buf === 1'b1)
  begin
    u0.report_unknown("RME");
    if ( WE_buf == 1'b0 )
    begin
      u0.flaga_read_ok = `False;
      -> u0.ev_read_out_a_port;
    end // if of WE_buf = 0
    u0.flaga_d_ok = `False;
    u0.checkSanityOnAport;
  end // if of RME_buf = X and ME_buf = 1
end // end of always block blk_posclock1_0


endmodule
`endcelldefine 
`ifdef verifault 
`disable_portfaults 
`nosuppress_faults 
`endif 


`ifdef VIRAGE_FAST_VERILOG
module generic_behav_ram4kx32_1p1r1w_bw (  Q, ADR, D, WEM, WE, ME, CLK, TEST1, RME, RM );
`else
module generic_behav_ram4kx32_1p1r1w_bw (  Q, ADR, D, WEM, WE, ME, CLK, TEST1, RME, RM,notif_adr, notif_d, notif_wem, notif_we, notif_me, notif_clk, notif_test1, notif_rme, notif_rm );
`endif // endif of VIRAGE_FAST_VERILOG

parameter PreloadFilename = "init.file";
parameter MES_ALL = "ON";
parameter words = 4096, bits = 32, addrbits = 12, O_delay=0.0, timingmode = 1, wembits=32, rmbits=4;

output [bits-1:0] Q;
input [addrbits-1:0] ADR;
input [bits-1:0] D;
input [wembits-1:0] WEM;
input WE;
input ME;
input CLK;
input TEST1;
input RME;
input [rmbits-1:0] RM;

`ifdef VIRAGE_FAST_VERILOG
`else
input notif_adr, notif_d, notif_wem, notif_we, notif_me, notif_clk, notif_test1, notif_rme, notif_rm;

`endif // endif of VIRAGE_FAST_VERILOG

parameter DataX = { bits { 1'bx } };
parameter DataZ = { bits { 1'bz } };

reg  [bits-1:0]  Q;
reg [addrbits-1:0] ADRlatched;

reg [addrbits-1:0] ADR_old;

reg [bits-1:0] Dlatched;

reg [bits-1:0] D_old;

reg [wembits-1:0] WEMlatched;

reg [wembits-1:0] WEM_old;

reg WElatched;
reg WE_old;
reg MElatched;
reg ME_old;
reg TEST1latched;
reg TEST1_old;
reg
  flaga_read_ok,
  flaga_we_ok,
  flaga_d_ok,
  WEM_violation,
  flaga_wem_ok,
  flaga_rm_ok,
  flaga_adr_ok,
  flaga_range_ok;
reg     flaga_clk_valid;
reg     flaga_viol;
event   ev_read_out_a_port;
event   ev_RST_out_a_port;
real CLK_TIME;
integer WEM_bit_count;
integer cnt_a;
real CLKA_T;
wire [31:0] WEMall;
reg [31:0] WEMbuslatched;
integer wem_bit_cnt_a;
wire   [31:0]  Q_temp;
reg    [31:0]  Q_local_tmp;
reg mes_all_valid;
integer i;
reg  [bits-1:0] mem_core_array [0:words -1];
reg[ 31:0] mem_core_array_read [0:4095];
reg [bits - 1:0] mem_core_row;

reg  [bits-1:0] mem_fault_array_XOR [0:words -1];
initial
begin
  for (i=0; i< words ; i=i+1)
    mem_fault_array_XOR[i]=0;
  `ifdef MEMFAULTINJ
  if ($test$plusargs("asap_error"))
  begin
    mem_fault_array_XOR[1] = 1'b1 << (bits - 1);
  end // if of +asap_error is used
  `endif
end

integer load_mem_cnt;
integer bit_cnt;


// Checks whether address input is Valid; 1-bit return value
function is_adr_Valid;  
input [addrbits-1:0] addr_to_check;
reg     ret_value;
begin
  ret_value = `True;
  if ((^addr_to_check) === 1'bx)
  begin
    ret_value = `False;
  end // if addr_to_check is X
  is_adr_Valid = ret_value;
end
endfunction

// Checks whether any bit of input is X; 1-bit return value
function is_x;  
input [bits-1:0] addr_to_check;
reg     ret_value;
begin
  ret_value = `False;
  if ((^addr_to_check) === 1'bx) 
  begin
    ret_value = `True;
  end // if of addr_to_check = X
  is_x = ret_value;
end
endfunction

// -------------------------------------------------------------------
// Common tasks
// -------------------------------------------------------------------

// Task to report unknown messages
task report_unknown;
input [8*5:1] signal;
begin
    if( MES_ALL=="ON" && $realtime != 0 && mes_all_valid )
    begin
      $display("<<%0s unknown>> at time=%t; instance=%m (RAMS1H)",signal,$realtime);
    end
end
endtask


// Corrupt Current Location
task corrupt_cur_locA;
input[11:0] Adr_to_corrupt;
begin
  if (is_adr_Valid(Adr_to_corrupt))
  begin
    if ( WEM_violation == `True )
    begin
      mem_core_array[Adr_to_corrupt] = 32'bx;
    end
    else
    begin
      mem_core_array[Adr_to_corrupt] = mem_core_array[Adr_to_corrupt] ^ ( WEMlatched & 32'bx);
    end
  end // if of is_adr_Valid(Adr_to_corrupt)
  else
  begin
    corrupt_all_loc(`True);
  end // else of if is_adr_Valid(Adr_to_corrupt)
end
endtask

// Corrupt Entire memory; Do not corrupt entire memory if address is out of range
// during Write; For all other cases, if flag_range_ok is true, corrupt entire memory
task corrupt_all_loc;
input flag_range_ok;
integer row_index;
begin
  if( flag_range_ok == `True)
  begin
    for( row_index = 0; row_index < words ; row_index = row_index + 1)
    begin
      mem_core_array[row_index] = 32'bx;
    end // end of for row_index loop
  end // if of flag_range_ok is true
end
endtask

// Check whether rm pin is valid or not
function is_rm_Valid;
input [rmbits-1:0] rm_to_chk;
reg ret_val;
begin
  ret_val = `True;
  if ((^rm_to_chk === 1'bx))
  begin
    ret_val = `False;
  end // if of rm_to_chk = X
  is_rm_Valid = ret_val;
end 
endfunction


// Perform Sanity Check on Port A, Corrupt memory if required

task checkSanityOnAport;
begin

  #0                // let CLOCK and NOTIFIER stuff execute first
  case ( {flaga_adr_ok, flaga_we_ok, flaga_d_ok,flaga_wem_ok} ) // only 1 and 0

    4'b1111   : ;                                               // everything ok!!!
    4'b1011,
    4'b1001   : if (WEMlatched !== {wembits{1'b0}})
                  corrupt_cur_locA(ADRlatched);        // WE is unstable
    4'b1010,
    4'b1000   : corrupt_cur_locA(ADRlatched);         // WE is unstable
    4'b1101   : if (WElatched === 1'b1 && WEMlatched !== {wembits{1'b0}})
                  corrupt_cur_locA(ADRlatched);        // Data is unstable
    4'b0001,
    4'b0011,
    4'b0000,
    4'b0010   : corrupt_all_loc(flaga_range_ok);           // ADR and WE unstable
    4'b0100,
    4'b0110   : if (WElatched !== 1'b0)
                  corrupt_all_loc(flaga_range_ok);
    4'b0101,
    4'b0111   :  corrupt_all_loc(flaga_range_ok);   // ADR unstable, WE stable
    4'b1100,
    4'b1110   : if (WElatched !== 1'b0)
                  corrupt_cur_locA(ADRlatched);        // WEM is unstable
  endcase
    flaga_adr_ok = `True;
    flaga_we_ok  = `True;
    flaga_wem_ok  = `True;
    flaga_d_ok  = `True;
 end
endtask // end of task checkSanityOnAport

// PORT A FUNCTIONALITY (Handle violation behavior)

reg INTERNAL_RESET; // For Internally resetting the memory(negedge of rscrst)

initial
begin
  mes_all_valid = 1'b0;
  flaga_adr_ok  = `True;
  flaga_range_ok = `True;
  flaga_we_ok   = `True;
  flaga_d_ok    = `True;
  flaga_wem_ok   = `True;
  flaga_read_ok = `True;
  flaga_rm_ok = `True;
  flaga_viol = `False;
  flaga_clk_valid = `True;
  `ifdef VIRAGE_IGNORE_RESET
  INTERNAL_RESET = 1'b0;
  #1 INTERNAL_RESET = 1'b1;
  #1 INTERNAL_RESET = 1'b0;
  `else
  `endif // endif of VIRAGE_IGNORE_RESET
end // end of initial block

// For Zerohold of ADR pin
always @( negedge CLK or ADR )
begin : blk_addrhold_0
  if ( CLK == 1'b0 )
  begin
    ADR_old = ADR;
  end // if of CLK = 0
end // end of always block blk_addrhold_0
// For Zerohold of D pin
always @( negedge CLK or D )
begin : blk_dihold_0
  if ( CLK == 1'b0 )
  begin
    D_old = D;
  end // if of CLK = 0
end // end of always block blk_dihold_0
// For Zerohold of WEM pin
always @( negedge CLK or WEM )
begin : blk_wemhold_0
  if ( CLK == 1'b0 )
  begin
    WEM_old = WEM;
  end // if of CLK = 0
end // end of always block blk_wemhold_0
// For Zerohold of WE pin
always @( negedge CLK or WE )
begin : blk_wehold_0
  if ( CLK == 1'b0 )
  begin
    WE_old = WE;
  end // if of CLK = 0
end // end of always block blk_wehold_0
// For Zerohold of ME pin
always @( negedge CLK or ME )
begin : blk_mehold_0
  if ( CLK == 1'b0 )
  begin
    ME_old = ME;
  end // if of CLK = 0
end // end of always block blk_mehold_0
// For Zerohold of Test1 pin
always @( negedge CLK or TEST1 )
begin : blk_test1hold_0
  if ( CLK == 1'b0 )
  begin
    TEST1_old = TEST1;
  end // if of CLK = 0
end // end of always block blk_test1hold_0

assign WEMall = {  WEM_old };

`ifdef VIRAGE_FAST_VERILOG
`else
// PORT A WE violation
always @(notif_we)           
begin : blk_notif_we_0
    if ( WE_old === 1'b0)
    begin
      flaga_viol = `True;
    end // if of WE_old = 0
    flaga_we_ok = `False;
    checkSanityOnAport;
    flaga_read_ok = `False;
    -> ev_read_out_a_port;
end // end of always block blk_notif_we_0

// PORT A CLK violation
always @(notif_clk)
begin : blk_notif_clk_0
  flaga_clk_valid = `False;
  flaga_adr_ok = `False;
  flaga_we_ok  = `False;
  flaga_wem_ok  = `False;
  checkSanityOnAport;
  flaga_read_ok = `False;     // irrespective of WE
  -> ev_read_out_a_port;
end // end of always block blk_notif_clk_0

// PORT A ME violation
always @(notif_me)           
begin : blk_notif_me_0
    flaga_viol = `True;
    flaga_read_ok = `False;                           
    -> ev_read_out_a_port;
    flaga_adr_ok = `False;
    checkSanityOnAport;
end // end of always block blk_notif_me_0

// PORT A ADR violation
always @(notif_adr)     
begin : blk_notif_addr_0
      flaga_viol = `True;
      flaga_read_ok = `False;                         
      -> ev_read_out_a_port;
      flaga_adr_ok = `False;
      corrupt_all_loc(`True);
end // end of always block blk_notif_addr_0

// PORT A D violation
always @(notif_d)     
begin : blk_notif_di_0
    flaga_viol = `True;
    flaga_read_ok = `False;
    -> ev_read_out_a_port;
    flaga_d_ok = `False;
    checkSanityOnAport;
end // end of always block blk_notif_di_0

//PORT A TEST1 violation
always @(notif_test1)   
begin : blk_notif_test1_0
//  ME_chk = ME_old;
    flaga_viol = `True;
    flaga_read_ok = `False;
    -> ev_read_out_a_port;
    flaga_d_ok  = `False;
    checkSanityOnAport;
end // end of always block blk_notif_test1_0

//PORT A RM violation
always @(notif_rm)       
begin : blk_notif_rm_0
    flaga_viol = `True;
    flaga_read_ok = `False;
    -> ev_read_out_a_port;
    flaga_d_ok  = `False;
    checkSanityOnAport;
end // end of always block blk_notif_rm_0

//PORT A RME violation
always @(notif_rme)  
begin : blk_notif_rmen_0
    flaga_viol = `True;
    flaga_read_ok = `False;
    -> ev_read_out_a_port;
    flaga_d_ok  = `False;
    checkSanityOnAport;
end // end of always block blk_notif_rmen_0


`endif // endif of VIRAGE_FAST_VERILOG


`ifdef VIRAGE_FAST_VERILOG
`else
//PORT A WEM violation
always @(notif_wem)     
begin : blk_notif_wem_0
    WEM_violation = `True;
    flaga_wem_ok  = `False;
    checkSanityOnAport;
end // end of always block blk_notif_wem_0
`endif // endif of VIRAGE_FAST_VERILOG

// reset for next cycle

always @(negedge CLK)
begin : blk_intnegclock_0
  if (flaga_clk_valid)
  begin
    flaga_adr_ok  = `True;
    flaga_we_ok   = `True;
    flaga_d_ok    = `True;
    flaga_wem_ok  = `True;
    flaga_viol    = `False;
  end // if of flaga_clk_valid is true
  if ( CLK !== 1'bx )
  begin
    #0.001;
    WEM_violation = `False;
    flaga_range_ok  = `True;
    flaga_read_ok = `True;
    flaga_rm_ok = `True;
    flaga_clk_valid = `True;
  end // if of CLK != X
  else
  begin
    flaga_clk_valid = `False;
    Q_local_tmp = 32'bx;
    corrupt_all_loc(`True);
    report_unknown("CLK");
  end // else of if CLK != X
end // end of always block blk_intnegclock_0

// PORT A FUNCTIONALITY 


always @(posedge CLK)
begin : blk_intposclock_0
  CLKA_T = $realtime;
  MElatched = ME_old;
  WElatched = WE_old;
  TEST1latched = TEST1_old;
  ADRlatched = ADR_old;
  Dlatched = D_old;
  WEMlatched = WEM_old;
  WEMbuslatched = WEMall;
  if (is_x(ADRlatched) == `True && MElatched !== 1'b0)
  begin
    report_unknown("ADR");
    if ( WElatched === 1'b1 )
    begin
      flaga_viol = `True;
    end // if of WElatched = 1
    else
    begin
      flaga_read_ok = `False;
    end
    `ifdef virage_ignore_read_addx
    if ((WElatched === 1'b1 && WEMlatched !== 32'b00000000000000000000000000000000))
    begin
      flaga_adr_ok = `False;
      corrupt_all_loc(flaga_range_ok);
    end // if of write
    `else
    flaga_adr_ok = `False;
    corrupt_all_loc(flaga_range_ok);
    `endif // endif of virage_ignore_read_addx is true
    -> ev_RST_out_a_port;
  end // if of is_x(ADRlatched) is true and MElatched != 0
  else if((ADRlatched > 12'b111111111111) && (MElatched === 1'b1) && (WElatched === 1'b1) )
  begin
    $display("\n%m VIRL_MEM_WARNING:address is out of range\n RANGE: 0 to 4095\n");
    flaga_range_ok = `False;
  end // if of ADRlatched out of range with MElatched = 1
  else
  begin
  end // else of if is_x(ADRlatched) is true and MElatched != 0
  if (!flaga_clk_valid) 
  begin
    Q_local_tmp = 32'bx;
  end // if of flaga_clk_valid is NOT true
  else if ( CLK === 1'bx )
  begin
    Q_local_tmp = 32'bx;
    corrupt_all_loc(flaga_range_ok);
    report_unknown("CLK");
  end // if of CLK = X
  else
  begin
      -> ev_RST_out_a_port;
  end // else of if CLK = X
end // end of always block blk_intposclock_0
// PORT A READ-OUT

always @(ev_read_out_a_port)
begin : blk_readout_0
  #0                // let CLOCK and NOTIFIER module execute first
  if (RME === 1'b1)
  begin
    if (RM >= 4'b0100)
    begin
      if( MES_ALL=="ON" && $realtime != 0)
      begin
      $display("RM = %b is not recommended value at time=%t; instance=%m (RAMS1H)",RM,$realtime);
      end
    end
  end
  else
  begin
  if (RM != 4'b0010)
  begin
    if( MES_ALL=="ON" && $realtime != 0)
    begin
      $display("RM = %b is not recommended value at time=%t; instance=%m (RAMS1H)",RM,$realtime);
    end // if of MES_ALL="ON" && $realtime != 0
  end // if of RM != 4'b0010
 end
  if (is_rm_Valid(RM) != `True)
  begin
    flaga_rm_ok = `False;
  end // if of is_rm_Valid(RM) is not true
  if (flaga_adr_ok && flaga_read_ok && flaga_rm_ok)
  begin : OUTPUT_a
    if (WElatched === 1'b0)
    begin
      if (ADRlatched <= 12'b111111111111)
      begin
          Q_local_tmp = mem_core_array[ADRlatched]^mem_fault_array_XOR[ADRlatched];
          Q_local_tmp = Q_local_tmp;
      end // if of ADRlatched <= 12'b111111111111
    end // if of WElatched = 0
  end //if of flaga_adr_ok is true and flaga_read_ok is true and flaga_rm_ok is true
  else
  begin
    if (flaga_viol)
    begin
      if ((WElatched === 1'b0 || (WElatched === 1'b1 && WEMlatched === 32'b00000000000000000000000000000000)))
      begin
        Q_local_tmp = 32'bx;
        flaga_read_ok = `True;
      end  //else if read 
    end // if of flaga_viol is true
    else
    begin
      Q_local_tmp = 32'bx;
      flaga_read_ok = `True;
    end // else of if flaga_viol is true
  end // else of if flaga_adr_ok is true and flaga_read_ok is true and flaga_rm_ok is true
end // end of always block blk_readout_0

// Handle Read/Write
always @(ev_RST_out_a_port)
begin : blk_readwrite_0
    if (MElatched !== 1'b0 && !flaga_viol)
    begin
      if (WElatched === 1'bx)
      begin
        flaga_we_ok = `False;
        flaga_read_ok = `False;
        report_unknown("WE");
      end // if of WElatched = X
      if ((^Dlatched === 1'bx))
      begin
        if (Dlatched === 32'bx)
        begin
          flaga_d_ok  = `False;
        end
        if (((|WEMlatched === 1'b1) || (^WEMlatched === 1'bX)) && WElatched !== 1'b0)
        begin
          report_unknown("D");
        end
      end
          if (TEST1latched === 1'bx)
          begin
            report_unknown("TEST1");
            if ( WElatched == 1'b1 )
            begin
              corrupt_cur_locA(ADRlatched);                             
            end // if of WElatched = 1
            else
            begin
              Q_local_tmp = 32'bx;
            end // else of if WElatched = 1
          end // if TEST1latched = X
          else
          begin
                if (^RM === 1'bx)
                begin
                  report_unknown("RM");
                  if ( WElatched == 1'b1 )
                  begin
                    corrupt_cur_locA(ADRlatched);
                  end // if of WElatched = 1
                  else
                  begin
                    Q_local_tmp = 32'bx;
                  end // else of if WElatched = 1
                end // if of RM = X
                else
                begin
                  if (MElatched !== 1'b1)
                  begin
                    flaga_we_ok = `False;       // don't know if cycle is On or Off
                  end // if of MElatched != 1 

                  if(ADRlatched > 12'b111111111111) 
                  begin
                    $display("\n%m VIRL_MEM_WARNING:address is out of range\n RANGE:0 to 4095\n");
                    flaga_range_ok = `False;
                    if (WElatched === 1'b0)
                    begin
                      flaga_read_ok = `False;
                    end // if of flaga_read_ok
                  end // if of ADRlatched out of range with MElatched = 1
                  if ( MElatched === 1'bx )
                  begin
                    report_unknown("ME");
                    `ifdef virage_ignore_read_addx
                    if (WElatched == 1'b1)
                    begin
                      corrupt_all_loc(flaga_range_ok);
                    end // if of WElatched = 1 
                    else
                    begin
                      Q_local_tmp = 32'bx;
                    end // else of if WElatched = 1
                    `else
                    if (WElatched == 1'b1)
                    begin
                      corrupt_all_loc(flaga_range_ok);
                    end // if of WElatched = 1
                    else
                    begin
                      Q_local_tmp = 32'bx;
                      corrupt_all_loc(flaga_range_ok);
                    end // else of if WElatched = 1
                    `endif
                  end // if of MElatched = X
                  else
                  begin
                      if ( ^WEMlatched === 1'bx )
                      begin
                        if ( WElatched == 1'b1 )
                        begin
                          report_unknown("WEM");
                        end // if of WElatched = 1
                      end // if of WEMlatched = X
                      if (flaga_range_ok && flaga_we_ok && flaga_wem_ok && flaga_adr_ok && flaga_d_ok && (WElatched == 1'b1))
                      begin
                        mem_core_array[ADRlatched] = ((mem_core_array[ADRlatched] & ~WEMbuslatched) | ( Dlatched & WEMbuslatched)) ^ ( WEMbuslatched ^ WEMbuslatched);
                          if (!mes_all_valid)
                          begin
                            mes_all_valid = 1'b1;
                          end // if of mes_all_valid = 0
                      end // if of write
                      else
                      begin
                        checkSanityOnAport;
                      end // else of if write
                  if (TEST1latched === 1'b1)
                  begin
                     if (WElatched === 1'b0)
                     begin
                       flaga_read_ok = `False;
                       -> ev_read_out_a_port;
                       @(negedge CLK);
                     end
                     -> ev_read_out_a_port;
                  end // if of TEST1latched = 1
                  else 
                  begin
                    -> ev_read_out_a_port;
                  end // else of if TEST1latched = 1
                  end // else of if MElatched = X
                end // else of if RM = X
          end // else of if TEST1latched = X
    end // if of MElatched != 0 & flaga_viol = 0
end // end of always block blk_readwrite_0



assign Q_temp = Q_local_tmp;

// Final Output Update 

always @( Q_temp )
begin : blk_output_0
    `ifdef VIRAGE_FAST_VERILOG
    #(O_delay) Q <= Q_temp;
    `else
    Q <= 32'bx;
    #0.001;
    Q <= Q_temp;
    `endif // endif of VIRAGE_FAST_VERILOG
end // end of always block blk_output_0


// Display the warning when TEST1 is 1.
always @ (TEST1)
begin : blk_test1_0
  if ( TEST1 == 1'b1)
  begin
    if( MES_ALL=="ON" && $realtime != 0 && mes_all_valid)
    begin
      $display("\n%m VERILOG> VIRL_MEM_WARNING: Tcc value in the RAM model is for TEST1=1'b0,but input value is TEST1=1'b1 (time %0t)\n\n", $time);
    end
  end // if TEST1 = 1 
end // end of always block blk_test1_0

endmodule
